{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Drift-v2 Python SDK","text":"<p>DriftPy is the Python SDK for Drift-v2 on Solana. It allows you to trade and fetch data from Drift using Python.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install driftpy\n</code></pre> <p>Note: requires Python &gt;= 3.10.</p>"},{"location":"#key-components","title":"Key Components","text":"<ul> <li><code>DriftClient</code> / <code>drift_client.py</code>: Used to interact with the protocol (deposit, withdraw, trade, lp, etc.)</li> <li><code>DriftUser</code> / <code>drift_user.py</code>: Used to fetch data from the protocol and view user metrics (leverage, free collateral, etc.)</li> <li><code>accounts.py</code>: Used to retrieve specific on-chain accounts (State, PerpMarket, SpotMarket, etc.)</li> <li><code>addresses.py</code>: Used to derive on-chain addresses of the accounts (publickey of the sol-market)</li> </ul>"},{"location":"#example","title":"Example","text":"<pre><code>from solana.keypair import Keypair\nfrom driftpy.drift_client import DriftClient\nfrom driftpy.drift_user import DriftUser\nfrom driftpy.constants.numeric_constants import BASE_PRECISION, AMM_RESERVE_PRECISION\n\nfrom anchorpy import Provider, Wallet\nfrom solana.rpc.async_api import AsyncClient\n\n# load keypair from file\nKEYPATH = '../your-keypair-secret.json'\nwith open(KEYPATH, 'r') as f:\n    secret = json.load(f)\nkp = Keypair.from_secret_key(bytes(secret))\n\n# create clearing house for mainnet\nENV = 'mainnet'\nconfig = configs[ENV]\nwallet = Wallet(kp)\nconnection = AsyncClient(config.default_http)\nprovider = Provider(connection, wallet)\n\ndrift_client = DriftClient.from_config(config, provider)\ndrift_user = DriftUser(drift_client)\n\n# open a 10 SOL long position\nsig = await drift_client.open_position(\n    PositionDirection.LONG(), # long\n    int(10 * BASE_PRECISION), # 10 in base precision\n    0, # sol market index\n)\n\n# mint 100 LP shares on the SOL market\nawait drift_client.add_liquidity(\n    int(100 * AMM_RESERVE_PRECISION),\n    0,\n)\n\n# inspect user's leverage\nleverage = await drift_user.get_leverage()\nprint('current leverage:', leverage / 10_000)\n\n# you can also inspect other accounts information using the (authority=) flag\nbigz_acc = DriftUser(drift_client, user_public_key=PublicKey('bigZ'))\nleverage = await bigz_acc.get_leverage()\nprint('bigZs leverage:', leverage / 10_000)\n\n# clearing house user calls can be expensive on the rpc so we can cache them\ndrift_user = DriftUser(drift_client, use_cache=True)\nawait drift_user.set_cache()\n\n# works without any rpc calls (uses the cached data)\nupnl = await drift_user.get_unrealized_pnl(with_funding=True)\nprint('upnl:', upnl)\n</code></pre>"},{"location":"accounts/","title":"Accounts","text":"<p>These functions are used to retrieve specific on-chain accounts (State, PerpMarket, SpotMarket, etc.)</p>"},{"location":"accounts/#example","title":"Example","text":"<pre><code>drift_client= DriftClient.from_config(config, provider)\n\n# get sol market info\nsol_market_index = 0\nsol_market = await get_perp_market_account(drift_client.program, sol_market_index)\nprint(\n    sol_market.amm.sqrt_k,\n    sol_market.amm.base_asset_amount_long,\n    sol_market.amm.base_asset_amount_short,\n)\n\n# get usdc spot market info\nusdc_spot_market_index = 0\nusdc_market = await get_spot_market_account(drift_client.program, usdc_spot_market_index)\nprint(\n    usdc.market_index,\n    usdc.deposit_balance,\n    usdc.borrow_balance,\n)\n</code></pre>"},{"location":"addresses/","title":"Addresses","text":"<p>These functions are used to derive on-chain addresses of the accounts (publickey of the sol-market)</p>"},{"location":"clearing_house/","title":"Drift Client","text":"<p>This object is used to interact with the protocol (deposit, withdraw, trade, lp, etc.)</p>"},{"location":"clearing_house/#example","title":"Example","text":"<pre><code>drift_client = DriftClient.from_config(config,provider)\n# open a 10 SOL long position\nsig = await drift_client.open_position(\n    PositionDirection.LONG(), # long\n    int(10 * BASE_PRECISION), # 10 in base precision\n    0, # sol market index\n)\n\n# mint 100 LP shares on the SOL market\nawait drift_client.add_liquidity(\n    int(100 * AMM_RESERVE_PRECISION),\n    0,\n)\n</code></pre>"},{"location":"clearing_house/#configuration","title":"Configuration","text":"<p>Use the <code>JUPITER_URL</code> environment variable to set the endpoint URL for the Jupiter V6 Swap API. This allows you to switch between self-hosted, paid-hosted, or other public API endpoints such as jupiterapi.com for higher rate limits and reduced latency. For more details, see the official self-hosted and paid-hosted documentation.</p>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient","title":"<code>DriftClient</code>","text":"<p>This class is the main way to interact with Drift Protocol including depositing, opening new positions, closing positions, placing orders, etc.</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>class DriftClient:\n    \"\"\"This class is the main way to interact with Drift Protocol including\n    depositing, opening new positions, closing positions, placing orders, etc.\n    \"\"\"\n\n    def __init__(\n        self,\n        connection: AsyncClient,\n        wallet: Union[Keypair, Wallet],\n        env: DriftEnv = \"mainnet\",\n        opts: TxOpts = DEFAULT_TX_OPTIONS,\n        authority: Pubkey = None,\n        account_subscription: Optional[\n            AccountSubscriptionConfig\n        ] = AccountSubscriptionConfig.default(),\n        perp_market_indexes: list[int] = None,\n        spot_market_indexes: list[int] = None,\n        oracle_infos: list[OracleInfo] = None,\n        tx_params: Optional[TxParams] = None,\n        tx_version: Optional[TransactionVersion] = None,\n        tx_sender: TxSender = None,\n        active_sub_account_id: Optional[int] = None,\n        sub_account_ids: Optional[list[int]] = None,\n        market_lookup_table: Optional[Pubkey] = None,\n        jito_params: Optional[JitoParams] = None,\n        enforce_tx_sequencing: bool = False,\n    ):\n        \"\"\"Initializes the drift client object\n\n        Args:\n            program (Program): Drift anchor program (see from_config on how to initialize it)\n            authority (Keypair, optional): Authority of all txs - if None will default to the Anchor Provider.Wallet Keypair.\n        \"\"\"\n        self.connection = connection\n\n        file = Path(str(driftpy.__path__[0]) + \"/idl/drift.json\")\n        with file.open() as f:\n            raw = file.read_text()\n        idl = Idl.from_json(raw)\n\n        provider = Provider(connection, wallet, opts)\n        self.program_id = DRIFT_PROGRAM_ID\n        self.program = Program(\n            idl,\n            self.program_id,\n            provider,\n        )\n\n        if isinstance(wallet, Keypair):\n            wallet = Wallet(wallet)\n\n        if authority is None:\n            authority = wallet.public_key\n\n        self.wallet = wallet\n        self.authority = authority\n\n        self.active_sub_account_id = (\n            active_sub_account_id if active_sub_account_id is not None else 0\n        )\n        self.sub_account_ids = (\n            sub_account_ids\n            if sub_account_ids is not None\n            else [self.active_sub_account_id]\n        )\n        self.users = {}\n\n        self.last_perp_market_seen_cache = {}\n        self.last_spot_market_seen_cache = {}\n\n        self.account_subscriber = account_subscription.get_drift_client_subscriber(\n            self.program, perp_market_indexes, spot_market_indexes, oracle_infos\n        )\n        self.account_subscription_config = account_subscription\n\n        self.market_lookup_table = (\n            market_lookup_table\n            if market_lookup_table is not None\n            else configs[env].market_lookup_table\n        )\n        self.market_lookup_table_account: Optional[AddressLookupTableAccount] = None\n\n        if tx_params is None:\n            tx_params = TxParams(600_000, 0)\n\n        self.tx_params = tx_params\n\n        self.tx_version = tx_version if tx_version is not None else Legacy\n\n        self.enforce_tx_sequencing = enforce_tx_sequencing\n        if self.enforce_tx_sequencing is True:\n            file = Path(str(driftpy.__path__[0]) + \"/idl/sequence_enforcer.json\")\n            with file.open() as f:\n                raw = file.read_text()\n            idl = Idl.from_json(raw)\n\n            provider = Provider(connection, wallet, opts)\n            self.sequence_enforcer_pid = (\n                SEQUENCER_PROGRAM_ID\n                if env == \"mainnet\"\n                else DEVNET_SEQUENCER_PROGRAM_ID\n            )\n            self.sequence_enforcer_program = Program(\n                idl,\n                self.sequence_enforcer_pid,\n                provider,\n            )\n            self.sequence_number_by_subaccount = {}\n            self.sequence_bump_by_subaccount = {}\n            self.sequence_initialized_by_subaccount = {}\n            self.sequence_address_by_subaccount = {}\n            self.resetting_sequence = False\n\n        if jito_params is not None:\n            from driftpy.tx.jito_tx_sender import JitoTxSender\n\n            self.tx_sender = JitoTxSender(\n                self,\n                opts,\n                jito_params.block_engine_url,\n                jito_params.jito_keypair,\n                blockhash_refresh_interval_secs=jito_params.blockhash_refresh_rate,\n                tip_amount=jito_params.tip_amount,\n            )\n        else:\n            self.tx_sender = (\n                StandardTxSender(self.connection, opts)\n                if tx_sender is None\n                else tx_sender\n            )\n\n    async def subscribe(self):\n        await self.account_subscriber.subscribe()\n        if self.enforce_tx_sequencing:\n            await self.load_sequence_info()\n        for sub_account_id in self.sub_account_ids:\n            await self.add_user(sub_account_id)\n\n    def resurrect(self, spot_markets, perp_markets, spot_oracles, perp_oracles):\n        from driftpy.accounts.cache import CachedDriftClientAccountSubscriber\n\n        if not isinstance(self.account_subscriber, CachedDriftClientAccountSubscriber):\n            raise ValueError(\n                'You can only resurrect a DriftClient that was initialized with AccountSubscriptionConfig(\"cached\")'\n            )\n        self.account_subscriber.resurrect(\n            spot_markets, perp_markets, spot_oracles, perp_oracles\n        )\n\n    async def add_user(self, sub_account_id: int):\n        if sub_account_id in self.users:\n            return\n\n        user = DriftUser(\n            drift_client=self,\n            user_public_key=self.get_user_account_public_key(sub_account_id),\n            account_subscription=self.account_subscription_config,\n        )\n        await user.subscribe()\n        self.users[sub_account_id] = user\n\n    async def unsubscribe(self):\n        await self.account_subscriber.unsubscribe()\n\n    def get_user(self, sub_account_id=None) -&gt; DriftUser:\n        sub_account_id = (\n            sub_account_id if sub_account_id is not None else self.active_sub_account_id\n        )\n        if sub_account_id not in self.users:\n            raise KeyError(f\"No sub account id {sub_account_id} found\")\n\n        return self.users[sub_account_id]\n\n    def get_user_account(self, sub_account_id=0) -&gt; UserAccount:\n        return self.get_user(sub_account_id).get_user_account()\n\n    def switch_active_user(self, sub_account_id: int):\n        self.active_sub_account_id = sub_account_id\n\n    def get_state_public_key(self):\n        return get_state_public_key(self.program_id)\n\n    def get_user_account_public_key(self, sub_account_id=None) -&gt; Pubkey:\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n        return get_user_account_public_key(\n            self.program_id, self.authority, sub_account_id\n        )\n\n    def get_user_stats_public_key(self):\n        return get_user_stats_account_public_key(self.program_id, self.authority)\n\n    def get_associated_token_account_public_key(self, market_index: int) -&gt; Pubkey:\n        spot_market = self.get_spot_market_account(market_index)\n        mint = spot_market.mint\n        return get_associated_token_address(self.wallet.public_key, mint)\n\n    def get_state_account(self) -&gt; Optional[StateAccount]:\n        state_and_slot = self.account_subscriber.get_state_account_and_slot()\n        return getattr(state_and_slot, \"data\", None)\n\n    def get_perp_market_account(self, market_index: int) -&gt; Optional[PerpMarketAccount]:\n        perp_market_and_slot = self.account_subscriber.get_perp_market_and_slot(\n            market_index\n        )\n        return getattr(perp_market_and_slot, \"data\", None)\n\n    def get_spot_market_account(self, market_index: int) -&gt; Optional[SpotMarketAccount]:\n        spot_market_and_slot = self.account_subscriber.get_spot_market_and_slot(\n            market_index\n        )\n        return getattr(spot_market_and_slot, \"data\", None)\n\n    def get_quote_spot_market_account(self) -&gt; Optional[SpotMarketAccount]:\n        spot_market_and_slot = self.account_subscriber.get_spot_market_and_slot(\n            QUOTE_SPOT_MARKET_INDEX\n        )\n        return getattr(spot_market_and_slot, \"data\", None)\n\n    def get_oracle_price_data(self, oracle: Pubkey) -&gt; Optional[OraclePriceData]:\n        oracle_price_data_and_slot = (\n            self.account_subscriber.get_oracle_price_data_and_slot(oracle)\n        )\n        return getattr(oracle_price_data_and_slot, \"data\", None)\n\n    def get_oracle_price_data_for_perp_market(\n        self, market_index: int\n    ) -&gt; Optional[OraclePriceData]:\n        data = self.account_subscriber.get_oracle_price_data_and_slot_for_perp_market(\n            market_index\n        )\n        if isinstance(data, DataAndSlot):\n            return getattr(\n                data,\n                \"data\",\n                None,\n            )\n\n        return data\n\n    def get_oracle_price_data_for_spot_market(\n        self, market_index: int\n    ) -&gt; Optional[OraclePriceData]:\n        data = self.account_subscriber.get_oracle_price_data_and_slot_for_spot_market(\n            market_index\n        )\n        if isinstance(data, DataAndSlot):\n            return getattr(\n                data,\n                \"data\",\n                None,\n            )\n\n        return data\n\n    def convert_to_spot_precision(self, amount: Union[int, float], market_index) -&gt; int:\n        spot_market = self.get_spot_market_account(market_index)\n        return cast_to_spot_precision(amount, spot_market)\n\n    def convert_to_perp_precision(self, amount: Union[int, float]) -&gt; int:\n        return int(amount * BASE_PRECISION)\n\n    def convert_to_price_precision(self, amount: Union[int, float]) -&gt; int:\n        return int(amount * PRICE_PRECISION)\n\n    def get_sub_account_id_for_ix(self, sub_account_id: int = None):\n        return (\n            sub_account_id if sub_account_id is not None else self.active_sub_account_id\n        )\n\n    async def fetch_market_lookup_table(self) -&gt; AddressLookupTableAccount:\n        if self.market_lookup_table_account is not None:\n            return self.market_lookup_table_account\n\n        self.market_lookup_table_account = await get_address_lookup_table(\n            self.connection, self.market_lookup_table\n        )\n        return self.market_lookup_table_account\n\n    async def send_ixs(\n        self,\n        ixs: Union[Instruction, list[Instruction]],\n        signers=None,\n        lookup_tables: list[AddressLookupTableAccount] = None,\n        tx_version: Optional[Union[Legacy, int]] = None,\n        sequencer_subaccount: Optional[int] = None,\n    ) -&gt; TxSigAndSlot:\n        if isinstance(ixs, Instruction):\n            ixs = [ixs]\n\n        if not tx_version:\n            tx_version = self.tx_version\n\n        compute_unit_instructions = []\n        if self.tx_params.compute_units is not None:\n            compute_unit_instructions.append(\n                set_compute_unit_limit(self.tx_params.compute_units)\n            )\n\n        if self.tx_params.compute_units_price is not None:\n            compute_unit_instructions.append(\n                set_compute_unit_price(self.tx_params.compute_units_price)\n            )\n\n        ixs[0:0] = compute_unit_instructions\n\n        subaccount = sequencer_subaccount or self.active_sub_account_id\n\n        if (\n            self.enforce_tx_sequencing\n            and self.sequence_initialized_by_subaccount[subaccount]\n            and not self.resetting_sequence\n        ):\n            sequence_instruction = self.get_check_and_set_sequence_number_ix(\n                self.sequence_number_by_subaccount[subaccount], subaccount\n            )\n            ixs.insert(len(compute_unit_instructions), sequence_instruction)\n\n        if tx_version == Legacy:\n            tx = await self.tx_sender.get_legacy_tx(ixs, self.wallet.payer, signers)\n        elif tx_version == 0:\n            if lookup_tables is None:\n                lookup_tables = [await self.fetch_market_lookup_table()]\n            tx = await self.tx_sender.get_versioned_tx(\n                ixs, self.wallet.payer, lookup_tables, signers\n            )\n        else:\n            raise NotImplementedError(\"unknown tx version\", self.tx_version)\n\n        return await self.tx_sender.send(tx)\n\n    def get_remaining_accounts(\n        self,\n        user_accounts: list[UserAccount] = (),\n        writable_perp_market_indexes: list[int] = (),\n        writable_spot_market_indexes: list[int] = (),\n        readable_spot_market_indexes: list[int] = (),\n        readable_perp_market_indexes: list[int] = (),\n    ):\n        (\n            oracle_map,\n            spot_market_map,\n            perp_market_map,\n        ) = self.get_remaining_accounts_for_users(user_accounts)\n\n        last_user_slot = self.get_user().get_user_account_and_slot().slot\n        for perp_market_index, slot in self.last_perp_market_seen_cache.items():\n            if slot &gt; last_user_slot:\n                self.add_perp_market_to_remaining_account_maps(\n                    perp_market_index,\n                    False,\n                    oracle_map,\n                    spot_market_map,\n                    perp_market_map,\n                )\n\n        for spot_market_index, slot in self.last_spot_market_seen_cache.items():\n            if slot &gt; last_user_slot:\n                self.add_spot_market_to_remaining_account_maps(\n                    spot_market_index, False, oracle_map, spot_market_map\n                )\n\n        for perp_market_index in readable_perp_market_indexes:\n            self.add_perp_market_to_remaining_account_maps(\n                perp_market_index, False, oracle_map, spot_market_map, perp_market_map\n            )\n\n        for spot_market_index in readable_spot_market_indexes:\n            self.add_spot_market_to_remaining_account_maps(\n                spot_market_index, False, oracle_map, spot_market_map\n            )\n\n        for perp_market_index in writable_perp_market_indexes:\n            self.add_perp_market_to_remaining_account_maps(\n                perp_market_index, True, oracle_map, spot_market_map, perp_market_map\n            )\n\n        for spot_market_index in writable_spot_market_indexes:\n            self.add_spot_market_to_remaining_account_maps(\n                spot_market_index, True, oracle_map, spot_market_map\n            )\n\n        remaining_accounts = [\n            *oracle_map.values(),\n            *spot_market_map.values(),\n            *perp_market_map.values(),\n        ]\n\n        return remaining_accounts\n\n    def add_perp_market_to_remaining_account_maps(\n        self,\n        market_index: int,\n        writable: bool,\n        oracle_account_map: dict[str, AccountMeta],\n        spot_market_account_map: dict[int, AccountMeta],\n        perp_market_account_map: dict[int, AccountMeta],\n    ) -&gt; None:\n        perp_market_account = self.get_perp_market_account(market_index)\n\n        perp_market_account_map[market_index] = AccountMeta(\n            pubkey=perp_market_account.pubkey, is_signer=False, is_writable=writable\n        )\n\n        oracle_writable = writable and is_variant(\n            perp_market_account.amm.oracle_source, \"Prelaunch\"\n        )\n        oracle_account_map[str(perp_market_account.amm.oracle)] = AccountMeta(\n            pubkey=perp_market_account.amm.oracle,\n            is_signer=False,\n            is_writable=oracle_writable,\n        )\n\n        self.add_spot_market_to_remaining_account_maps(\n            perp_market_account.quote_spot_market_index,\n            False,\n            oracle_account_map,\n            spot_market_account_map,\n        )\n\n    def add_spot_market_to_remaining_account_maps(\n        self,\n        market_index: int,\n        writable: bool,\n        oracle_account_map: dict[str, AccountMeta],\n        spot_market_account_map: dict[int, AccountMeta],\n    ) -&gt; None:\n        spot_market_account = self.get_spot_market_account(market_index)\n\n        spot_market_account_map[market_index] = AccountMeta(\n            pubkey=spot_market_account.pubkey, is_signer=False, is_writable=writable\n        )\n\n        if spot_market_account.oracle != Pubkey.default():\n            oracle_account_map[str(spot_market_account.oracle)] = AccountMeta(\n                pubkey=spot_market_account.oracle, is_signer=False, is_writable=False\n            )\n\n    def get_remaining_accounts_for_users(\n        self, user_accounts: list[UserAccount]\n    ) -&gt; (dict[str, AccountMeta], dict[int, AccountMeta], dict[int, AccountMeta]):\n        oracle_map = {}\n        spot_market_map = {}\n        perp_market_map = {}\n\n        for user_account in user_accounts:\n            for spot_position in user_account.spot_positions:\n                if not is_spot_position_available(spot_position):\n                    self.add_spot_market_to_remaining_account_maps(\n                        spot_position.market_index, False, oracle_map, spot_market_map\n                    )\n\n                if spot_position.open_asks != 0 or spot_position.open_bids != 0:\n                    self.add_spot_market_to_remaining_account_maps(\n                        QUOTE_SPOT_MARKET_INDEX, False, oracle_map, spot_market_map\n                    )\n\n            for position in user_account.perp_positions:\n                if not is_available(position):\n                    self.add_perp_market_to_remaining_account_maps(\n                        position.market_index,\n                        False,\n                        oracle_map,\n                        spot_market_map,\n                        perp_market_map,\n                    )\n\n        return oracle_map, spot_market_map, perp_market_map\n\n    async def initialize_user(\n        self,\n        sub_account_id: int = 0,\n        name: str = None,\n        referrer_info: ReferrerInfo = None,\n    ):\n        \"\"\"intializes a drift user\n\n        Args:\n            sub_account_id (int, optional): subaccount id to initialize. Defaults to 0.\n\n        Returns:\n            str: tx signature\n        \"\"\"\n        ixs = []\n        if sub_account_id == 0:\n            ixs.append(self.get_initialize_user_stats())\n            if name is None:\n                name = DEFAULT_USER_NAME\n\n        if name is None:\n            name = \"Subaccount \" + str(sub_account_id + 1)\n\n        ix = self.get_initialize_user_instructions(sub_account_id, name, referrer_info)\n        ixs.append(ix)\n        return (await self.send_ixs(ixs)).tx_sig\n\n    def get_initialize_user_stats(\n        self,\n    ):\n        state_public_key = self.get_state_public_key()\n        user_stats_public_key = self.get_user_stats_public_key()\n\n        return self.program.instruction[\"initialize_user_stats\"](\n            ctx=Context(\n                accounts={\n                    \"user_stats\": user_stats_public_key,\n                    \"state\": state_public_key,\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"payer\": self.wallet.payer.pubkey(),\n                    \"rent\": RENT,\n                    \"system_program\": ID,\n                },\n            ),\n        )\n\n    def get_initialize_user_instructions(\n        self,\n        sub_account_id: int = 0,\n        name: str = DEFAULT_USER_NAME,\n        referrer_info: ReferrerInfo = None,\n    ) -&gt; Instruction:\n        user_public_key = self.get_user_account_public_key(sub_account_id)\n        state_public_key = self.get_state_public_key()\n        user_stats_public_key = self.get_user_stats_public_key()\n\n        encoded_name = encode_name(name)\n\n        remaining_accounts = []\n        if referrer_info is not None:\n            remaining_accounts.append(\n                AccountMeta(referrer_info.referrer, is_writable=True, is_signer=False)\n            )\n            remaining_accounts.append(\n                AccountMeta(\n                    referrer_info.referrer_stats, is_writable=True, is_signer=False\n                )\n            )\n\n        initialize_user_account_ix = self.program.instruction[\"initialize_user\"](\n            sub_account_id,\n            encoded_name,\n            ctx=Context(\n                accounts={\n                    \"user\": user_public_key,\n                    \"user_stats\": user_stats_public_key,\n                    \"state\": state_public_key,\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"payer\": self.wallet.payer.pubkey(),\n                    \"rent\": RENT,\n                    \"system_program\": ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n        return initialize_user_account_ix\n\n    async def deposit(\n        self,\n        amount: int,\n        spot_market_index: int,\n        user_token_account: Pubkey = None,\n        sub_account_id: int = None,\n        reduce_only=False,\n        user_initialized=True,\n    ):\n        \"\"\"deposits collateral into protocol\n\n        Args:\n            amount (int): amount to deposit\n            spot_market_index (int):\n            user_token_account (Pubkey):\n            sub_account_id (int, optional): subaccount to deposit into. Defaults to 0.\n            reduce_only (bool, optional): paying back borrow vs depositing new assets. Defaults to False.\n            user_initialized (bool, optional): if need to initialize user account too set this to False. Defaults to True.\n\n        Returns:\n            str: sig\n        \"\"\"\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                self.get_deposit_collateral_ix(\n                    amount,\n                    spot_market_index,\n                    user_token_account,\n                    sub_account_id,\n                    reduce_only,\n                    user_initialized,\n                )\n            ]\n        )\n        self.last_spot_market_seen_cache[spot_market_index] = tx_sig_and_slot.slot\n        return tx_sig_and_slot\n\n    def get_deposit_collateral_ix(\n        self,\n        amount: int,\n        spot_market_index: int,\n        user_token_account: Pubkey = None,\n        sub_account_id: int = None,\n        reduce_only=False,\n        user_initialized=True,\n    ) -&gt; Instruction:\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        if user_initialized:\n            remaining_accounts = self.get_remaining_accounts(\n                writable_spot_market_indexes=[spot_market_index],\n                user_accounts=[self.get_user_account(sub_account_id)],\n            )\n        else:\n            raise Exception(\"not implemented...\")\n\n        user_token_account = (\n            user_token_account\n            if user_token_account is not None\n            else self.get_associated_token_account_public_key(spot_market_index)\n        )\n\n        spot_market_pk = get_spot_market_public_key(self.program_id, spot_market_index)\n        spot_vault_public_key = get_spot_market_vault_public_key(\n            self.program_id, spot_market_index\n        )\n        user_account_public_key = get_user_account_public_key(\n            self.program_id, self.authority, sub_account_id\n        )\n        return self.program.instruction[\"deposit\"](\n            spot_market_index,\n            amount,\n            reduce_only,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"spot_market\": spot_market_pk,\n                    \"spot_market_vault\": spot_vault_public_key,\n                    \"user\": user_account_public_key,\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"user_token_account\": user_token_account,\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def withdraw(\n        self,\n        amount: int,\n        market_index: int,\n        user_token_account: Pubkey,\n        reduce_only: bool = False,\n        sub_account_id: int = None,\n    ):\n        \"\"\"withdraws from drift protocol (can also allow borrowing)\n\n        Args:\n            amount (int): amount to withdraw\n            market_index (int):\n            user_token_account (Pubkey): ata of the account to withdraw to\n            reduce_only (bool, optional): if True will only withdraw existing funds else if False will allow taking out borrows. Defaults to False.\n            sub_account_id (int, optional): subaccount. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                self.get_withdraw_collateral_ix(\n                    amount,\n                    market_index,\n                    user_token_account,\n                    reduce_only,\n                    sub_account_id,\n                )\n            ]\n        )\n        self.last_spot_market_seen_cache[market_index] = tx_sig_and_slot.slot\n        return tx_sig_and_slot\n\n    def get_withdraw_collateral_ix(\n        self,\n        amount: int,\n        market_index: int,\n        user_token_account: Pubkey,\n        reduce_only: bool = False,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        spot_market = self.get_spot_market_account(market_index)\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)],\n            writable_spot_market_indexes=[market_index],\n        )\n        dc_signer = get_drift_client_signer_public_key(self.program_id)\n\n        return self.program.instruction[\"withdraw\"](\n            market_index,\n            amount,\n            reduce_only,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"spot_market\": spot_market.pubkey,\n                    \"spot_market_vault\": spot_market.vault,\n                    \"drift_signer\": dc_signer,\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"user_token_account\": user_token_account,\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def transfer_deposit(\n        self,\n        amount: int,\n        market_index: int,\n        from_sub_account_id: int,\n        to_sub_account_id: int,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                await self.get_transfer_deposit_ix(\n                    amount,\n                    market_index,\n                    from_sub_account_id,\n                    to_sub_account_id,\n                )\n            ]\n        )\n        self.last_spot_market_seen_cache[market_index] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    async def get_transfer_deposit_ix(\n        self,\n        amount: int,\n        market_index: int,\n        from_sub_account_id: int,\n        to_sub_account_id: int,\n    ):\n        from_user_public_key = self.get_user_account_public_key(from_sub_account_id)\n        to_user_public_key = self.get_user_account_public_key(to_sub_account_id)\n\n        if from_sub_account_id not in self.users:\n            from_user_account = await self.program.account[\"User\"].fetch(\n                from_user_public_key\n            )\n        else:\n            from_user_account = self.get_user_account(from_sub_account_id)\n\n        if to_sub_account_id not in self.users:\n            to_user_account = await self.program.account[\"User\"].fetch(\n                to_user_public_key\n            )\n        else:\n            to_user_account = self.get_user_account(to_sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_spot_market_indexes=[\n                market_index,\n            ],\n            user_accounts=[from_user_account, to_user_account],\n        )\n\n        ix = self.program.instruction[\"transfer_deposit\"](\n            market_index,\n            amount,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"from_user\": from_user_public_key,\n                    \"to_user\": to_user_public_key,\n                    \"authority\": self.wallet.public_key,\n                    \"spot_market_vault\": self.get_spot_market_account(\n                        market_index\n                    ).vault,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return ix\n\n    async def place_spot_order(\n        self,\n        order_params: OrderParams,\n        sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                self.get_place_spot_order_ix(order_params, sub_account_id),\n            ]\n        )\n        self.last_spot_market_seen_cache[\n            order_params.market_index\n        ] = tx_sig_and_slot.slot\n        self.last_spot_market_seen_cache[QUOTE_SPOT_MARKET_INDEX] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    def get_place_spot_order_ix(\n        self,\n        order_params: OrderParams,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        order_params.set_spot()\n        user_account_public_key = self.get_user_account_public_key(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            readable_spot_market_indexes=[\n                QUOTE_SPOT_MARKET_INDEX,\n                order_params.market_index,\n            ],\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        ix = self.program.instruction[\"place_spot_order\"](\n            order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.wallet.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return ix\n\n    async def place_perp_order(\n        self,\n        order_params: OrderParams,\n        sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                self.get_place_perp_order_ix(order_params, sub_account_id),\n            ]\n        )\n        self.last_perp_market_seen_cache[\n            order_params.market_index\n        ] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    def get_place_perp_order_ix(\n        self,\n        order_params: OrderParams,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        order_params.set_perp()\n        user_account_public_key = self.get_user_account_public_key(sub_account_id)\n        user_stats_public_key = self.get_user_stats_public_key()\n        remaining_accounts = self.get_remaining_accounts(\n            readable_perp_market_indexes=[order_params.market_index],\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        ix = self.program.instruction[\"place_perp_order\"](\n            order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"userStats\": user_stats_public_key,\n                    \"authority\": self.wallet.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return ix\n\n    async def place_orders(\n        self,\n        order_params: List[OrderParams],\n        sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                self.get_place_orders_ix(order_params, sub_account_id),\n            ]\n        )\n\n        for order_param in order_params:\n            if is_variant(order_param.market_type, \"Perp\"):\n                self.last_perp_market_seen_cache[\n                    order_param.market_index\n                ] = tx_sig_and_slot.slot\n            else:\n                self.last_spot_market_seen_cache[\n                    order_param.market_index\n                ] = tx_sig_and_slot.slot\n\n        return tx_sig_and_slot.tx_sig\n\n    def get_place_orders_ix(\n        self,\n        order_params: List[OrderParams],\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        user_account_public_key = self.get_user_account_public_key(sub_account_id)\n        user_stats_public_key = self.get_user_stats_public_key()\n\n        readable_perp_market_indexes = []\n        readable_spot_market_indexes = []\n        for order_param in order_params:\n            order_param.check_market_type()\n\n            if is_variant(order_param.market_type, \"Perp\"):\n                readable_perp_market_indexes.append(order_param.market_index)\n            else:\n                if len(readable_spot_market_indexes) == 0:\n                    readable_spot_market_indexes.append(QUOTE_SPOT_MARKET_INDEX)\n\n                readable_spot_market_indexes.append(order_param.market_index)\n\n        remaining_accounts = self.get_remaining_accounts(\n            readable_perp_market_indexes=readable_perp_market_indexes,\n            readable_spot_market_indexes=readable_spot_market_indexes,\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        ix = self.program.instruction[\"place_orders\"](\n            order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"userStats\": user_stats_public_key,\n                    \"authority\": self.wallet.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return ix\n\n    async def cancel_order(\n        self,\n        order_id: Optional[int] = None,\n        sub_account_id: int = None,\n    ):\n        \"\"\"cancel specific order (if order_id=None will be most recent order)\n\n        Args:\n            order_id (Optional[int], optional): Defaults to None.\n            sub_account_id (int, optional): subaccount id which contains order. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return (\n            await self.send_ixs(\n                self.get_cancel_order_ix(order_id, sub_account_id),\n            )\n        ).tx_sig\n\n    def get_cancel_order_ix(\n        self, order_id: Optional[int] = None, sub_account_id: int = None\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)]\n        )\n\n        return self.program.instruction[\"cancel_order\"](\n            order_id,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def cancel_order_by_user_id(\n        self,\n        user_order_id: int,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        return (\n            await self.send_ixs(\n                self.get_cancel_order_by_user_id_ix(user_order_id, sub_account_id),\n            )\n        ).tx_sig\n\n    def get_cancel_order_by_user_id_ix(\n        self, user_order_id: int, sub_account_id: int = None\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)]\n        )\n\n        return self.program.instruction[\"cancel_order_by_user_id\"](\n            user_order_id,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def cancel_orders(\n        self,\n        market_type: MarketType = None,\n        market_index: int = None,\n        direction: PositionDirection = None,\n        sub_account_id: int = None,\n    ):\n        \"\"\"cancel all existing orders on the book\n\n        Args:\n            market_type (MarketType, optional): only cancel orders for single market, used with market_index\n            market_index (int, optional): only cancel orders for single market, used with market_type\n            direction: (PositionDirection, optional): only cancel bids or asks\n            sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return (\n            await self.send_ixs(\n                self.get_cancel_orders_ix(\n                    market_type, market_index, direction, sub_account_id\n                )\n            )\n        ).tx_sig\n\n    def get_cancel_orders_ix(\n        self,\n        market_type: MarketType = None,\n        market_index: int = None,\n        direction: PositionDirection = None,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)]\n        )\n\n        return self.program.instruction[\"cancel_orders\"](\n            market_type,\n            market_index,\n            direction,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def cancel_and_place_orders(\n        self,\n        cancel_params: (\n            Optional[MarketType],\n            Optional[int],\n            Optional[PositionDirection],\n        ),\n        place_order_params: List[OrderParams],\n        sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            self.get_cancel_and_place_orders_ix(\n                cancel_params, place_order_params, sub_account_id\n            ),\n        )\n\n        for order_param in place_order_params:\n            if is_variant(order_param.market_type, \"Perp\"):\n                self.last_perp_market_seen_cache[\n                    order_param.market_index\n                ] = tx_sig_and_slot.slot\n            else:\n                self.last_spot_market_seen_cache[\n                    order_param.market_index\n                ] = tx_sig_and_slot.slot\n\n        return tx_sig_and_slot.tx_sig\n\n    def get_cancel_and_place_orders_ix(\n        self,\n        cancel_params: (\n            Optional[MarketType],\n            Optional[int],\n            Optional[PositionDirection],\n        ),\n        place_order_params: List[OrderParams],\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        market_type, market_index, direction = cancel_params\n\n        cancel_orders_ix = self.get_cancel_orders_ix(\n            market_type, market_index, direction, sub_account_id\n        )\n        place_orders_ix = self.get_place_orders_ix(place_order_params, sub_account_id)\n        return [cancel_orders_ix, place_orders_ix]\n\n    async def modify_order(\n        self,\n        order_id: int,\n        modify_order_params: ModifyOrderParams,\n        sub_account_id: int = None,\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    self.get_modify_order_ix(\n                        order_id, modify_order_params, sub_account_id\n                    )\n                ],\n            )\n        ).tx_sig\n\n    def get_modify_order_ix(\n        self,\n        order_id: int,\n        modify_order_params: ModifyOrderParams,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        return self.program.instruction[\"modify_order\"](\n            order_id,\n            modify_order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def modify_order_by_user_id(\n        self,\n        user_order_id: int,\n        modify_order_params: ModifyOrderParams,\n        sub_account_id: int = None,\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    self.get_modify_order_by_user_id_ix(\n                        user_order_id, modify_order_params, sub_account_id\n                    )\n                ],\n            )\n        ).tx_sig\n\n    def get_modify_order_by_user_id_ix(\n        self,\n        user_order_id: int,\n        modify_order_params: ModifyOrderParams,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        return self.program.instruction[\"modify_order_by_user_id\"](\n            user_order_id,\n            modify_order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def place_and_take_perp_order(\n        self,\n        order_params: OrderParams,\n        maker_info: MakerInfo = None,\n        sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                self.get_place_and_take_perp_order_ix(\n                    order_params, maker_info, sub_account_id\n                ),\n            ]\n        )\n        self.last_perp_market_seen_cache[\n            order_params.market_index\n        ] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    def get_place_and_take_perp_order_ix(\n        self,\n        order_params: OrderParams,\n        maker_info: MakerInfo = None,\n        sub_account_id: int = None,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        order_params.set_perp()\n\n        user_account_public_key = self.get_user_account_public_key(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[order_params.market_index],\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        maker_order_id = None\n        if maker_info is not None:\n            maker_order_id = maker_info.order.order_id\n            remaining_accounts.append(\n                AccountMeta(pubkey=maker_info.maker, is_signer=False, is_writable=True)\n            )\n\n        return self.program.instruction[\"place_and_take_perp_order\"](\n            order_params,\n            maker_order_id,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def add_liquidity(\n        self, amount: int, market_index: int, sub_account_id: int = None\n    ):\n        \"\"\"mint LP tokens and add liquidity to the DAMM\n\n        Args:\n            amount (int): amount of lp tokens to mint\n            market_index (int): market you want to lp in\n            sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        tx_sig_and_slot = await self.send_ixs(\n            [self.get_add_liquidity_ix(amount, market_index, sub_account_id)]\n        )\n\n        self.last_perp_market_seen_cache[market_index] = tx_sig_and_slot.slot\n\n        return tx_sig_and_slot.tx_sig\n\n    def get_add_liquidity_ix(\n        self, amount: int, market_index: int, sub_account_id: int = None\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[market_index],\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n        user_account_public_key = get_user_account_public_key(\n            self.program_id, self.authority, sub_account_id\n        )\n\n        return self.program.instruction[\"add_perp_lp_shares\"](\n            amount,\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def remove_liquidity(\n        self, amount: int, market_index: int, sub_account_id: int = None\n    ):\n        \"\"\"burns LP tokens and removes liquidity to the DAMM\n\n        Args:\n            amount (int): amount of lp tokens to burn\n            market_index (int):\n            sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return (\n            await self.send_ixs(\n                [self.get_remove_liquidity_ix(amount, market_index, sub_account_id)]\n            )\n        ).tx_sig\n\n    def get_remove_liquidity_ix(\n        self, amount: int, market_index: int, sub_account_id: int = None\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[market_index],\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n        user_account_public_key = self.get_user_account_public_key(sub_account_id)\n\n        return self.program.instruction[\"remove_perp_lp_shares\"](\n            amount,\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def settle_lp(\n        self,\n        settlee_user_account_public_key: Pubkey,\n        market_index: int,\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    await self.get_settle_lp_ix(\n                        settlee_user_account_public_key, market_index\n                    )\n                ],\n                signers=[],\n            )\n        ).tx_sig\n\n    async def get_settle_lp_ix(\n        self,\n        settlee_user_account_public_key: Pubkey,\n        market_index: int,\n    ):\n        settlee_user_account = await self.program.account[\"User\"].fetch(\n            settlee_user_account_public_key\n        )\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[market_index],\n            user_accounts=[settlee_user_account],\n        )\n\n        return self.program.instruction[\"settle_lp\"](\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": settlee_user_account_public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    def get_spot_position(\n        self,\n        market_index: int,\n        sub_account_id: int = None,\n    ) -&gt; Optional[SpotPosition]:\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        return self.get_user(sub_account_id).get_spot_position(market_index)\n\n    def get_perp_position(\n        self,\n        market_index: int,\n        sub_account_id: int = None,\n    ) -&gt; Optional[PerpPosition]:\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n        return self.get_user(sub_account_id).get_perp_position(market_index)\n\n    async def liquidate_spot(\n        self,\n        user_authority: Pubkey,\n        asset_market_index: int,\n        liability_market_index: int,\n        max_liability_transfer: int,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                await self.get_liquidate_spot_ix(\n                    user_authority,\n                    asset_market_index,\n                    liability_market_index,\n                    max_liability_transfer,\n                    user_sub_account_id,\n                    liq_sub_account_id,\n                )\n            ]\n        )\n        self.last_spot_market_seen_cache[asset_market_index] = tx_sig_and_slot.slot\n        self.last_spot_market_seen_cache[liability_market_index] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    async def get_liquidate_spot_ix(\n        self,\n        user_authority: Pubkey,\n        asset_market_index: int,\n        liability_market_index: int,\n        max_liability_transfer: int,\n        limit_price: int = None,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, sub_account_id=user_sub_account_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_sub_account_id = self.get_sub_account_id_for_ix(liq_sub_account_id)\n        liq_pk = self.get_user_account_public_key(liq_sub_account_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        user_account = await self.program.account[\"User\"].fetch(user_pk)\n        liq_user_account = self.get_user_account(liq_sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_spot_market_indexes=[liability_market_index, asset_market_index],\n            user_accounts=[user_account, liq_user_account],\n        )\n\n        return self.program.instruction[\"liquidate_spot\"](\n            asset_market_index,\n            liability_market_index,\n            max_liability_transfer,\n            limit_price,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def liquidate_perp(\n        self,\n        user_authority: Pubkey,\n        market_index: int,\n        max_base_asset_amount: int,\n        limit_price: Optional[int] = None,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            [\n                await self.get_liquidate_perp_ix(\n                    user_authority,\n                    market_index,\n                    max_base_asset_amount,\n                    limit_price,\n                    user_sub_account_id,\n                    liq_sub_account_id,\n                )\n            ]\n        )\n        self.last_perp_market_seen_cache[market_index] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    async def get_liquidate_perp_ix(\n        self,\n        user_authority: Pubkey,\n        market_index: int,\n        max_base_asset_amount: int,\n        limit_price: Optional[int] = None,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_sub_account_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_sub_account_id = self.get_sub_account_id_for_ix(liq_sub_account_id)\n        liq_pk = self.get_user_account_public_key(liq_sub_account_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        user_account = await self.program.account[\"User\"].fetch(user_pk)\n        liq_user_account = self.get_user_account(liq_sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[market_index],\n            user_accounts=[user_account, liq_user_account],\n        )\n\n        return self.program.instruction[\"liquidate_perp\"](\n            market_index,\n            max_base_asset_amount,\n            limit_price,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def liquidate_perp_pnl_for_deposit(\n        self,\n        user_authority: Pubkey,\n        perp_market_index: int,\n        spot_market_index: int,\n        max_pnl_transfer: int,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        tx_sig_and_slot = await self.send_ixs(\n            await self.get_liquidate_perp_pnl_for_deposit_ix(\n                user_authority,\n                perp_market_index,\n                spot_market_index,\n                max_pnl_transfer,\n                user_sub_account_id,\n                liq_sub_account_id,\n            )\n        )\n        self.last_spot_market_seen_cache[spot_market_index] = tx_sig_and_slot.slot\n        self.last_perp_market_seen_cache[perp_market_index] = tx_sig_and_slot.slot\n        return tx_sig_and_slot.tx_sig\n\n    async def get_liquidate_perp_pnl_for_deposit_ix(\n        self,\n        user_authority: Pubkey,\n        perp_market_index: int,\n        spot_market_index: int,\n        max_pnl_transfer: int,\n        limit_price: int = None,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_sub_account_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_sub_account_id = self.get_sub_account_id_for_ix(liq_sub_account_id)\n        liq_pk = self.get_user_account_public_key(liq_sub_account_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        user_account = await self.program.account[\"User\"].fetch(user_pk)\n        liq_user_account = self.get_user_account(liq_sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[perp_market_index],\n            writable_spot_market_indexes=[spot_market_index],\n            user_accounts=[user_account, liq_user_account],\n        )\n\n        result = self.program.instruction[\"liquidate_perp_pnl_for_deposit\"](\n            perp_market_index,\n            spot_market_index,\n            max_pnl_transfer,\n            limit_price,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n        return result\n\n    async def settle_pnl(\n        self,\n        settlee_user_account_public_key: Pubkey,\n        settlee_user_account: UserAccount,\n        market_index: int,\n    ):\n        return (\n            await self.send_ixs(\n                self.get_settle_pnl_ix(\n                    settlee_user_account_public_key, settlee_user_account, market_index\n                )\n            )\n        ).tx_sig\n\n    def get_settle_pnl_ix(\n        self,\n        settlee_user_public_key: Pubkey,\n        settlee_user_account: UserAccount,\n        market_index: int,\n    ):\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[market_index],\n            writable_spot_market_indexes=[QUOTE_SPOT_MARKET_INDEX],\n            user_accounts=[settlee_user_account],\n        )\n\n        instruction = self.program.instruction[\"settle_pnl\"](\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"user\": settlee_user_public_key,\n                    \"spot_market_vault\": get_spot_market_vault_public_key(\n                        self.program_id, QUOTE_SPOT_MARKET_INDEX\n                    ),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return instruction\n\n    def get_settle_pnl_ixs(\n        self, users: dict[Pubkey, UserAccount], market_indexes: list[int]\n    ) -&gt; list[Instruction]:\n        ixs: list[Instruction] = []\n        for pubkey, account in users.items():\n            for market_index in market_indexes:\n                ix = self.get_settle_pnl_ix(pubkey, account, market_index)\n                ixs.append(ix)\n\n        return ixs\n\n    async def resolve_spot_bankruptcy(\n        self,\n        user_authority: Pubkey,\n        spot_market_index: int,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    await self.get_resolve_spot_bankruptcy_ix(\n                        user_authority,\n                        spot_market_index,\n                        user_sub_account_id,\n                        liq_sub_account_id,\n                    )\n                ]\n            )\n        ).tx_sig\n\n    async def get_resolve_spot_bankruptcy_ix(\n        self,\n        user_authority: Pubkey,\n        spot_market_index: int,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_sub_account_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_sub_account_id = self.get_sub_account_id_for_ix(liq_sub_account_id)\n        liq_pk = self.get_user_account_public_key(liq_sub_account_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        user_account = await self.program.account[\"User\"].fetch(user_pk)\n        liq_user_account = self.get_user_account(liq_sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_spot_market_indexes=[spot_market_index],\n            user_accounts=[user_account, liq_user_account],\n        )\n\n        if_vault = get_insurance_fund_vault_public_key(\n            self.program_id, spot_market_index\n        )\n        spot_vault = get_spot_market_vault_public_key(\n            self.program_id, spot_market_index\n        )\n        dc_signer = get_drift_client_signer_public_key(self.program_id)\n\n        return self.program.instruction[\"resolve_spot_bankruptcy\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                    \"spot_market_vault\": spot_vault,\n                    \"insurance_fund_vault\": if_vault,\n                    \"drift_signer\": dc_signer,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def resolve_perp_bankruptcy(\n        self,\n        user_authority: Pubkey,\n        market_index: int,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    await self.get_resolve_perp_bankruptcy_ix(\n                        user_authority,\n                        market_index,\n                        user_sub_account_id,\n                        liq_sub_account_id,\n                    )\n                ]\n            )\n        ).tx_sig\n\n    async def get_resolve_perp_bankruptcy_ix(\n        self,\n        user_authority: Pubkey,\n        market_index: int,\n        user_sub_account_id: int = 0,\n        liq_sub_account_id: int = None,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_sub_account_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_sub_account_id = self.get_sub_account_id_for_ix(liq_sub_account_id)\n        liq_pk = self.get_user_account_public_key(liq_sub_account_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        user_account = await self.program.account[\"User\"].fetch(user_pk)\n        liq_user_account = self.get_user_account(liq_sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            writable_perp_market_indexes=[market_index],\n            user_accounts=[user_account, liq_user_account],\n        )\n\n        if_vault = get_insurance_fund_vault_public_key(self.program_id, market_index)\n        spot_vault = get_spot_market_vault_public_key(self.program_id, market_index)\n        dc_signer = get_drift_client_signer_public_key(self.program_id)\n\n        return self.program.instruction[\"resolve_perp_bankruptcy\"](\n            QUOTE_SPOT_MARKET_INDEX,\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                    \"spot_market_vault\": spot_vault,\n                    \"insurance_fund_vault\": if_vault,\n                    \"drift_signer\": dc_signer,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def settle_expired_market(\n        self,\n        market_index: int,\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    await self.get_settle_expired_market_ix(\n                        market_index,\n                    ),\n                ]\n            )\n        ).tx_sig\n\n    async def get_settle_expired_market_ix(\n        self,\n        market_index: int,\n    ):\n        market = await get_perp_market_account(self.program, market_index)\n\n        market_account_infos = [\n            AccountMeta(\n                pubkey=market.pubkey,\n                is_writable=True,\n                is_signer=False,\n            )\n        ]\n\n        oracle_account_infos = [\n            AccountMeta(\n                pubkey=market.amm.oracle,\n                is_writable=False,\n                is_signer=False,\n            )\n        ]\n\n        spot_pk = get_spot_market_public_key(self.program_id, QUOTE_SPOT_MARKET_INDEX)\n        spot_account_infos = [\n            AccountMeta(\n                pubkey=spot_pk,\n                is_writable=True,\n                is_signer=False,\n            )\n        ]\n\n        remaining_accounts = (\n            oracle_account_infos + spot_account_infos + market_account_infos\n        )\n\n        return self.program.instruction[\"settle_expired_market\"](\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def request_remove_insurance_fund_stake(\n        self, spot_market_index: int, amount: int\n    ):\n        return (\n            await self.send_ixs(\n                self.get_request_remove_insurance_fund_stake_ix(\n                    spot_market_index, amount\n                )\n            )\n        ).tx_sig\n\n    def get_request_remove_insurance_fund_stake_ix(\n        self,\n        spot_market_index: int,\n        amount: int,\n    ):\n        ra = self.get_remaining_accounts(\n            writable_spot_market_indexes=[spot_market_index],\n        )\n\n        return self.program.instruction[\"request_remove_insurance_fund_stake\"](\n            spot_market_index,\n            amount,\n            ctx=Context(\n                accounts={\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                },\n                remaining_accounts=ra,\n            ),\n        )\n\n    async def cancel_request_remove_insurance_fund_stake(self, spot_market_index: int):\n        return (\n            await self.send_ixs(\n                self.get_cancel_request_remove_insurance_fund_stake_ix(\n                    spot_market_index\n                )\n            )\n        ).tx_sig\n\n    def get_cancel_request_remove_insurance_fund_stake_ix(\n        self, spot_market_index: int, user_token_account: Pubkey = None\n    ):\n        ra = self.get_remaining_accounts(\n            writable_spot_market_indexes=[spot_market_index]\n        )\n\n        return self.program.instruction[\"cancel_request_remove_insurance_fund_stake\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                },\n                remaining_accounts=ra,\n            ),\n        )\n\n    async def remove_insurance_fund_stake(\n        self, spot_market_index: int, user_token_account: Pubkey = None\n    ):\n        return (\n            await self.send_ixs(\n                self.get_remove_insurance_fund_stake_ix(\n                    spot_market_index, user_token_account\n                )\n            )\n        ).tx_sig\n\n    def get_remove_insurance_fund_stake_ix(\n        self, spot_market_index: int, user_token_account: Pubkey = None\n    ):\n        ra = self.get_remaining_accounts(\n            writable_spot_market_indexes=[spot_market_index],\n        )\n\n        user_token_account = (\n            user_token_account\n            if user_token_account is not None\n            else self.get_associated_token_account_public_key(spot_market_index)\n        )\n\n        return self.program.instruction[\"remove_insurance_fund_stake\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_drift_client_signer_public_key(self.program_id),\n                    \"user_token_account\": user_token_account,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=ra,\n            ),\n        )\n\n    async def add_insurance_fund_stake(\n        self, spot_market_index: int, amount: int, user_token_account: Pubkey = None\n    ):\n        return (\n            await self.send_ixs(\n                self.get_add_insurance_fund_stake_ix(\n                    spot_market_index, amount, user_token_account\n                )\n            )\n        ).tx_sig\n\n    def get_add_insurance_fund_stake_ix(\n        self, spot_market_index: int, amount: int, user_token_account: Pubkey = None\n    ):\n        remaining_accounts = self.get_remaining_accounts(\n            writable_spot_market_indexes=[spot_market_index],\n        )\n\n        user_token_account = (\n            user_token_account\n            if user_token_account is not None\n            else self.get_associated_token_account_public_key(spot_market_index)\n        )\n\n        return self.program.instruction[\"add_insurance_fund_stake\"](\n            spot_market_index,\n            amount,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"spot_market_vault\": get_spot_market_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_drift_client_signer_public_key(self.program_id),\n                    \"user_token_account\": user_token_account,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def initialize_insurance_fund_stake(\n        self,\n        spot_market_index: int,\n    ):\n        return (\n            await self.send_ixs(\n                self.get_initialize_insurance_fund_stake_ix(spot_market_index)\n            )\n        ).tx_sig\n\n    def get_initialize_insurance_fund_stake_ix(\n        self,\n        spot_market_index: int,\n    ):\n        return self.program.instruction[\"initialize_insurance_fund_stake\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"state\": get_state_public_key(self.program_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"payer\": self.wallet.payer.pubkey(),\n                    \"rent\": RENT,\n                    \"system_program\": ID,\n                }\n            ),\n        )\n\n    async def fill_perp_order(\n        self,\n        user_account_pubkey: Pubkey,\n        user_account: UserAccount,\n        order: Order,\n        maker_info: Optional[Union[MakerInfo, list[MakerInfo]]],\n        referrer_info: Optional[ReferrerInfo],\n    ):\n        return (\n            await self.send_ixs(\n                [\n                    await self.get_fill_perp_order_ix(\n                        user_account_pubkey,\n                        user_account,\n                        order,\n                        maker_info,\n                        referrer_info,\n                    )\n                ]\n            )\n        ).tx_sig\n\n    async def get_fill_perp_order_ix(\n        self,\n        user_account_pubkey: Pubkey,\n        user_account: UserAccount,\n        order: Order,\n        maker_info: Optional[Union[MakerInfo, list[MakerInfo]]],\n        referrer_info: Optional[ReferrerInfo],\n    ) -&gt; Instruction:\n        user_stats_pubkey = get_user_stats_account_public_key(\n            self.program.program_id, user_account.authority\n        )\n\n        filler_pubkey = self.get_user_account_public_key()\n        filler_stats_pubkey = self.get_user_stats_public_key()\n\n        market_index = (\n            order.market_index\n            if order\n            else next(\n                (\n                    order.market_index\n                    for order in user_account.orders\n                    if order.order_id == user_account.next_order_id - 1\n                ),\n                None,\n            )\n        )\n\n        maker_info = (\n            maker_info\n            if isinstance(maker_info, list)\n            else [maker_info]\n            if maker_info\n            else []\n        )\n\n        user_accounts = [user_account]\n        for maker in maker_info:\n            user_accounts.append(maker.maker_user_account)\n\n        remaining_accounts = self.get_remaining_accounts(user_accounts, [market_index])\n\n        for maker in maker_info:\n            remaining_accounts.append(\n                AccountMeta(pubkey=maker.maker, is_writable=True, is_signer=False)\n            )\n            remaining_accounts.append(\n                AccountMeta(pubkey=maker.maker_stats, is_writable=True, is_signer=False)\n            )\n\n        if referrer_info:\n            referrer_is_maker = any(\n                maker.maker == referrer_info.referrer for maker in maker_info\n            )\n            if not referrer_is_maker:\n                remaining_accounts.append(\n                    AccountMeta(\n                        pubkey=referrer_info.referrer, is_writable=True, is_signer=False\n                    )\n                )\n                remaining_accounts.append(\n                    AccountMeta(\n                        pubkey=referrer_info.referrer_stats,\n                        is_writable=True,\n                        is_signer=False,\n                    )\n                )\n\n        order_id = order.order_id\n        return self.program.instruction[\"fill_perp_order\"](\n            order_id,\n            None,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"filler\": filler_pubkey,\n                    \"filler_stats\": filler_stats_pubkey,\n                    \"user\": user_account_pubkey,\n                    \"user_stats\": user_stats_pubkey,\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    def get_revert_fill_ix(self):\n        filler_pubkey = self.get_user_account_public_key()\n        filler_stats_pubkey = self.get_user_stats_public_key()\n\n        return self.program.instruction[\"revert_fill\"](\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"filler\": filler_pubkey,\n                    \"filler_stats\": filler_stats_pubkey,\n                    \"authority\": self.wallet.payer.pubkey(),\n                }\n            )\n        )\n\n    def get_trigger_order_ix(\n        self,\n        user_account_pubkey: Pubkey,\n        user_account: UserAccount,\n        order: Order,\n        filler_pubkey: Optional[Pubkey] = None,\n    ):\n        filler = filler_pubkey or self.get_user_account_public_key()\n\n        if is_variant(order.market_type, \"Perp\"):\n            remaining_accounts = self.get_remaining_accounts(\n                user_accounts=[user_account],\n                writable_perp_market_indexes=[order.market_index],\n            )\n        else:\n            remaining_accounts = self.get_remaining_accounts(\n                user_accounts=[user_account],\n                writable_spot_market_indexes=[\n                    order.market_index,\n                    QUOTE_SPOT_MARKET_INDEX,\n                ],\n            )\n\n        return self.program.instruction[\"trigger_order\"](\n            order.order_id,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"filler\": filler,\n                    \"user\": user_account_pubkey,\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def force_cancel_orders(\n        self,\n        user_account_pubkey: Pubkey,\n        user_account: UserAccount,\n        filler_pubkey: Optional[Pubkey] = None,\n    ) -&gt; Signature:\n        tx_sig_and_slot = await self.send_ixs(\n            self.get_force_cancel_orders_ix(\n                user_account_pubkey, user_account, filler_pubkey\n            )\n        )\n\n        return tx_sig_and_slot.tx_sig\n\n    def get_force_cancel_orders_ix(\n        self,\n        user_account_pubkey: Pubkey,\n        user_account: UserAccount,\n        filler_pubkey: Optional[Pubkey] = None,\n    ):\n        filler = filler_pubkey or self.get_user_account_public_key()\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[user_account],\n            writable_spot_market_indexes=[QUOTE_SPOT_MARKET_INDEX],\n        )\n\n        return self.program.instruction[\"force_cancel_orders\"](\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"filler\": filler,\n                    \"user\": user_account_pubkey,\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            )\n        )\n\n    @deprecated\n    async def open_position(\n        self,\n        direction: PositionDirection,\n        amount: int,\n        market_index: int,\n        sub_account_id: int = None,\n        limit_price: int = 0,\n        ioc: bool = False,\n    ):\n        return (\n            await self.send_ixs(\n                self.get_open_position_ix(\n                    direction,\n                    amount,\n                    market_index,\n                    sub_account_id,\n                    limit_price,\n                    ioc,\n                ),\n            )\n        ).tx_sig\n\n    @deprecated\n    def get_open_position_ix(\n        self,\n        direction: PositionDirection,\n        amount: int,\n        market_index: int,\n        sub_account_id: int = None,\n        limit_price: int = 0,\n        ioc: bool = False,\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        order_params = OrderParams(\n            order_type=OrderType.Market(),\n            direction=direction,\n            market_index=market_index,\n            base_asset_amount=amount,\n            price=limit_price,\n        )\n\n        ix = self.get_place_and_take_perp_order_ix(\n            order_params, sub_account_id=sub_account_id\n        )\n        return ix\n\n    @deprecated\n    async def close_position(\n        self, market_index: int, limit_price: int = 0, sub_account_id: int = None\n    ):\n        return (\n            await self.send_ixs(\n                self.get_close_position_ix(\n                    market_index, limit_price, sub_account_id=sub_account_id\n                )\n            )\n        ).tx_sig\n\n    @deprecated\n    def get_close_position_ix(\n        self, market_index: int, limit_price: int = 0, sub_account_id: int = None\n    ):\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        position = self.get_perp_position(market_index, sub_account_id)\n        if position is None or position.base_asset_amount == 0:\n            print(\"=&gt; user has no position to close...\")\n            return\n\n        order_params = OrderParams(\n            order_type=OrderType.Market(),\n            market_index=market_index,\n            base_asset_amount=abs(int(position.base_asset_amount)),\n            direction=PositionDirection.Long()\n            if position.base_asset_amount &lt; 0\n            else PositionDirection.Short(),\n            price=limit_price,\n            reduce_only=True,\n        )\n\n        ix = self.get_place_and_take_perp_order_ix(\n            order_params, sub_account_id=sub_account_id\n        )\n        return ix\n\n    async def update_amm(self, market_indexs: list[int]):\n        return (await self.send_ixs(self.get_update_amm_ix(market_indexs))).tx_sig\n\n    def get_update_amm_ix(\n        self,\n        market_indexs: list[int],\n    ):\n        n = len(market_indexs)\n        for _ in range(5 - n):\n            market_indexs.append(100)\n\n        market_infos = []\n        oracle_infos = []\n        for idx in market_indexs:\n            if idx != 100:\n                market = self.get_perp_market_account(idx)\n                market_infos.append(\n                    AccountMeta(\n                        pubkey=market.pubkey,\n                        is_signer=False,\n                        is_writable=True,\n                    )\n                )\n                oracle_infos.append(\n                    AccountMeta(\n                        pubkey=market.amm.oracle, is_signer=False, is_writable=False\n                    )\n                )\n\n        remaining_accounts = oracle_infos + market_infos\n\n        return self.program.instruction[\"update_amms\"](\n            market_indexs,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def settle_revenue_to_insurance_fund(self, spot_market_index: int):\n        return await self.program.rpc[\"settle_revenue_to_insurance_fund\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"spot_market_vault\": get_spot_market_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_drift_client_signer_public_key(self.program_id),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id,\n                        spot_market_index,\n                    ),\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                }\n            ),\n        )\n\n    def create_associated_token_account_idempotent_instruction(\n        self, account: Pubkey, payer: Pubkey, owner: Pubkey, mint: Pubkey\n    ):\n        return Instruction(\n            accounts=[\n                AccountMeta(pubkey=payer, is_signer=True, is_writable=True),\n                AccountMeta(pubkey=account, is_signer=False, is_writable=True),\n                AccountMeta(pubkey=owner, is_signer=False, is_writable=False),\n                AccountMeta(pubkey=mint, is_signer=False, is_writable=False),\n                AccountMeta(pubkey=SYS_PROGRAM_ID, is_signer=False, is_writable=False),\n                AccountMeta(\n                    pubkey=TOKEN_PROGRAM_ID, is_signer=False, is_writable=False\n                ),\n                AccountMeta(pubkey=RENT, is_signer=False, is_writable=False),\n            ],\n            program_id=ASSOCIATED_TOKEN_PROGRAM_ID,\n            data=bytes([0x01]),\n        )\n\n    async def get_swap_flash_loan_ix(\n        self,\n        out_market_index: int,\n        in_market_index: int,\n        amount_in: int,\n        in_ata: Pubkey,\n        out_ata: Pubkey,\n        limit_price: Optional[int] = 0,\n        reduce_only: Optional[SwapReduceOnly] = None,\n        user_account_public_key: Optional[Pubkey] = None,\n    ):\n        user_public_key_to_use = (\n            user_account_public_key\n            if user_account_public_key\n            else (self.get_user_account_public_key())\n        )\n\n        user_accounts = []\n\n        try:\n            user_accounts.append(self.get_user().get_user_account_and_slot().data)\n        except:\n            pass  # ignore\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=user_accounts,\n            writable_spot_market_indexes=[out_market_index, in_market_index],\n            readable_spot_market_indexes=[QUOTE_SPOT_MARKET_INDEX],\n        )\n\n        out_market = self.get_spot_market_account(out_market_index)\n        in_market = self.get_spot_market_account(in_market_index)\n\n        sysvar_pubkey = Pubkey.from_string(\n            \"Sysvar1nstructions1111111111111111111111111\"\n        )\n\n        begin_swap_ix = self.program.instruction[\"begin_swap\"](\n            in_market_index,\n            out_market_index,\n            amount_in,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_public_key_to_use,\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"authority\": self.wallet.public_key,\n                    \"out_spot_market_vault\": out_market.vault,\n                    \"in_spot_market_vault\": in_market.vault,\n                    \"in_token_account\": in_ata,\n                    \"out_token_account\": out_ata,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                    \"drift_signer\": self.get_state_account().signer,\n                    \"instructions\": sysvar_pubkey,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        end_swap_ix = self.program.instruction[\"end_swap\"](\n            in_market_index,\n            out_market_index,\n            limit_price,\n            reduce_only,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_public_key_to_use,\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"authority\": self.wallet.public_key,\n                    \"out_spot_market_vault\": out_market.vault,\n                    \"in_spot_market_vault\": in_market.vault,\n                    \"in_token_account\": in_ata,\n                    \"out_token_account\": out_ata,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                    \"drift_signer\": self.get_state_account().signer,\n                    \"instructions\": sysvar_pubkey,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return begin_swap_ix, end_swap_ix\n\n    async def get_jupiter_swap_ix_v6(\n        self,\n        out_market_idx: int,\n        in_market_idx: int,\n        amount: int,\n        out_ata: Optional[Pubkey] = None,\n        in_ata: Optional[Pubkey] = None,\n        slippage_bps: Optional[int] = None,\n        quote=None,\n        reduce_only: Optional[SwapReduceOnly] = None,\n        user_account_public_key: Optional[Pubkey] = None,\n    ) -&gt; Tuple[list[Instruction], list[AddressLookupTableAccount]]:\n        pre_instructions: list[Instruction] = []\n        JUPITER_URL = os.getenv(\"JUPITER_URL\", \"https://quote-api.jup.ag/v6\")\n\n        out_market = self.get_spot_market_account(out_market_idx)\n        in_market = self.get_spot_market_account(in_market_idx)\n\n        if slippage_bps is None:\n            slippage_bps = 10\n\n        if quote is None:\n            url = f\"{JUPITER_URL}/quote?inputMint={str(in_market.mint)}&amp;outputMint={str(out_market.mint)}&amp;amount={amount}&amp;slippageBps={slippage_bps}\"\n\n            quote_resp = requests.get(url)\n\n            if quote_resp.status_code != 200:\n                raise Exception(\"Couldn't get a Jupiter quote\")\n\n            quote = quote_resp.json()\n\n        if out_ata is None:\n            out_ata: Pubkey = self.get_associated_token_account_public_key(\n                out_market.market_index\n            )\n\n            ai = await self.connection.get_account_info(out_ata)\n\n            if not ai.value:\n                pre_instructions.append(\n                    self.create_associated_token_account_idempotent_instruction(\n                        out_ata,\n                        self.wallet.public_key,\n                        self.wallet.public_key,\n                        out_market.mint,\n                    )\n                )\n\n        if in_ata is None:\n            in_ata: Pubkey = self.get_associated_token_account_public_key(\n                in_market.market_index\n            )\n\n            ai = await self.connection.get_account_info(in_ata)\n\n            if not ai.value:\n                pre_instructions.append(\n                    self.create_associated_token_account_idempotent_instruction(\n                        in_ata,\n                        self.wallet.public_key,\n                        self.wallet.public_key,\n                        in_market.mint,\n                    )\n                )\n\n        data = {\n            \"quoteResponse\": quote,\n            \"userPublicKey\": str(self.wallet.public_key),\n            \"destinationTokenAccount\": str(out_ata),\n        }\n\n        swap_ix_resp = requests.post(\n            f\"{JUPITER_URL}/swap-instructions\",\n            headers={\"Accept\": \"application/json\", \"Content-Type\": \"application/json\"},\n            data=json.dumps(data),\n        )\n\n        if swap_ix_resp.status_code != 200:\n            raise Exception(\"Couldn't get Jupiter swap ix\")\n\n        swap_ix_json = swap_ix_resp.json()\n\n        swap_ix = swap_ix_json.get(\"swapInstruction\")\n        address_table_lookups = swap_ix_json.get(\"addressLookupTableAddresses\")\n\n        address_table_lookup_accounts: list[AddressLookupTableAccount] = []\n\n        for table_pubkey in address_table_lookups:\n            address_table_lookup_account = await get_address_lookup_table(\n                self.connection, Pubkey.from_string(table_pubkey)\n            )\n            address_table_lookup_accounts.append(address_table_lookup_account)\n\n        swap_ixs = [swap_ix]\n\n        begin_swap_ix, end_swap_ix = await self.get_swap_flash_loan_ix(\n            out_market_idx,\n            in_market_idx,\n            amount,\n            in_ata,\n            out_ata,\n            None,\n            reduce_only,\n            user_account_public_key,\n        )\n\n        ixs = [*pre_instructions, begin_swap_ix, *swap_ixs, end_swap_ix]\n        cleansed_ixs: list[Instruction] = []\n\n        for ix in ixs:\n            if type(ix) == list:\n                for i in ix:\n                    if type(i) == dict:\n                        cleansed_ixs.append(self._dict_to_instructions(i))\n            elif type(ix) == dict:\n                cleansed_ixs.append(self._dict_to_instructions(ix))\n            else:\n                cleansed_ixs.append(ix)\n\n        return cleansed_ixs, address_table_lookup_accounts\n\n    def _dict_to_instructions(self, instructions_dict: dict) -&gt; Instruction:\n        program_id = Pubkey.from_string(instructions_dict[\"programId\"])\n        accounts = [\n            AccountMeta(\n                Pubkey.from_string(account[\"pubkey\"]),\n                account[\"isSigner\"],\n                account[\"isWritable\"],\n            )\n            for account in instructions_dict[\"accounts\"]\n        ]\n        data = base64.b64decode(instructions_dict[\"data\"])\n        return Instruction(program_id, data, accounts)\n\n    def get_perp_market_accounts(self) -&gt; list[PerpMarketAccount]:\n        return [\n            value.data\n            for value in self.account_subscriber.get_market_accounts_and_slots()\n            if value is not None\n        ]\n\n    def get_spot_market_accounts(self) -&gt; list[SpotMarketAccount]:\n        return [\n            value.data\n            for value in self.account_subscriber.get_spot_market_accounts_and_slots()\n            if value is not None\n        ]\n\n    def get_market_index_and_type(\n        self, name: str\n    ) -&gt; Union[Tuple[int, MarketType], None]:\n        \"\"\"\n        Returns the market index and type for a given market name \\n\n        Returns `None` if the market name couldn't be matched \\n\n        e.g. \"SOL-PERP\" -&gt; `(0, MarketType.Perp())`\n        \"\"\"\n        name = name.upper()\n        for perp_market_account in self.get_perp_market_accounts():\n            if decode_name(perp_market_account.name).upper() == name:\n                return (perp_market_account.market_index, MarketType.Perp())\n\n        for spot_market_account in self.get_spot_market_accounts():\n            if decode_name(spot_market_account.name).upper() == name:\n                return (spot_market_account.market_index, MarketType.Spot())\n\n        return None  # explicitly return None if no match is found\n\n    def get_update_user_margin_trading_enabled_ix(\n        self,\n        margin_trading_enabled: bool,\n        sub_account_id: Optional[int] = None,\n    ) -&gt; Instruction:\n        sub_account_id = self.get_sub_account_id_for_ix(sub_account_id)\n\n        remaining_accounts = self.get_remaining_accounts(\n            user_accounts=[self.get_user_account(sub_account_id)],\n        )\n\n        return self.program.instruction[\"update_user_margin_trading_enabled\"](\n            sub_account_id,\n            margin_trading_enabled,\n            ctx=Context(\n                accounts={\n                    \"user\": self.get_user_account_public_key(sub_account_id),\n                    \"authority\": self.wallet.payer.pubkey(),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def update_user_margin_trading_enabled(\n        self, margin_trading_enabled: bool, sub_account_id: Optional[int] = None\n    ):\n        \"\"\"Toggles margin trading for a user\n\n        Args:\n            sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        await self.add_user(sub_account_id)\n\n        tx_sig = await self.send_ixs(\n            [\n                self.get_update_user_margin_trading_enabled_ix(\n                    margin_trading_enabled=margin_trading_enabled,\n                    sub_account_id=sub_account_id,\n                )\n            ]\n        ).tx_sig\n        return tx_sig\n\n    async def update_prelaunch_oracle(\n        self,\n        market_index: int,\n    ):\n        return (\n            await self.send_ixs(\n                self.get_update_prelaunch_oracle_ix(\n                    market_index,\n                ),\n            )\n        ).tx_sig\n\n    def get_update_prelaunch_oracle_ix(self, market_index: int):\n        perp_market = self.get_perp_market_account(market_index)\n\n        if not is_variant(perp_market.amm.oracle_source, \"Prelaunch\"):\n            raise ValueError(f\"wrong oracle source: {perp_market.amm.oracle_source}\")\n\n        return self.program.instruction[\"update_prelaunch_oracle\"](\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"perp_market\": perp_market.pubkey,\n                    \"oracle\": perp_market.amm.oracle,\n                }\n            )\n        )\n\n    async def init_sequence(self, subaccount: int = 0) -&gt; Signature:\n        try:\n            sig = (await self.send_ixs([self.get_sequence_init_ix(subaccount)])).tx_sig\n            self.sequence_initialized_by_subaccount[subaccount] = True\n            return sig\n        except Exception as e:\n            print(f\"WARNING: failed to initialize sequence: {e}\")\n\n    def get_sequence_init_ix(self, subaccount: int = 0) -&gt; Instruction:\n        if self.enforce_tx_sequencing is False:\n            raise ValueError(\"tx sequencing is disabled\")\n        return self.sequence_enforcer_program.instruction[\"initialize\"](\n            self.sequence_bump_by_subaccount[subaccount],\n            str(subaccount),\n            ctx=Context(\n                accounts={\n                    \"sequence_account\": self.sequence_address_by_subaccount[subaccount],\n                    \"authority\": self.wallet.payer.pubkey(),\n                    \"system_program\": ID,\n                }\n            ),\n        )\n\n    async def reset_sequence_number(\n        self, sequence_number: int = 0, subaccount: int = 0\n    ) -&gt; Signature:\n        try:\n            ix = self.get_reset_sequence_number_ix(sequence_number)\n            self.resetting_sequence = True\n            sig = (await self.send_ixs(ix)).tx_sig\n            self.resetting_sequence = False\n            self.sequence_number_by_subaccount[subaccount] = sequence_number\n            return sig\n        except Exception as e:\n            print(f\"WARNING: failed to reset sequence number: {e}\")\n\n    def get_reset_sequence_number_ix(\n        self, sequence_number: int, subaccount: int = 0\n    ) -&gt; Instruction:\n        if self.enforce_tx_sequencing is False:\n            raise ValueError(\"tx sequencing is disabled\")\n        return self.sequence_enforcer_program.instruction[\"reset_sequence_number\"](\n            sequence_number,\n            ctx=Context(\n                accounts={\n                    \"sequence_account\": self.sequence_address_by_subaccount[subaccount],\n                    \"authority\": self.wallet.payer.pubkey(),\n                }\n            ),\n        )\n\n    def get_check_and_set_sequence_number_ix(\n        self, sequence_number: Optional[int] = None, subaccount: int = 0\n    ):\n        if self.enforce_tx_sequencing is False:\n            raise ValueError(\"tx sequencing is disabled\")\n        sequence_number = (\n            sequence_number or self.sequence_number_by_subaccount[subaccount]\n        )\n\n        if (\n            sequence_number &lt; self.sequence_number_by_subaccount[subaccount] - 1\n        ):  # we increment after creating the ix, so we check - 1\n            print(\n                f\"WARNING: sequence number {sequence_number} &lt; last used {self.sequence_number_by_subaccount[subaccount] - 1}\"\n            )\n\n        ix = self.sequence_enforcer_program.instruction[\n            \"check_and_set_sequence_number\"\n        ](\n            sequence_number,\n            ctx=Context(\n                accounts={\n                    \"sequence_account\": self.sequence_address_by_subaccount[subaccount],\n                    \"authority\": self.wallet.payer.pubkey(),\n                }\n            ),\n        )\n\n        self.sequence_number_by_subaccount[subaccount] += 1\n        return ix\n\n    async def load_sequence_info(self):\n        for subaccount in self.sub_account_ids:\n            address, bump = get_sequencer_public_key_and_bump(\n                self.sequence_enforcer_pid, self.wallet.payer.pubkey(), subaccount\n            )\n            try:\n                sequence_account_raw = await self.sequence_enforcer_program.account[\n                    \"SequenceAccount\"\n                ].fetch(address)\n            except anchorpy.error.AccountDoesNotExistError as e:\n                self.sequence_address_by_subaccount[subaccount] = address\n                self.sequence_number_by_subaccount[subaccount] = 1\n                self.sequence_bump_by_subaccount[subaccount] = bump\n                self.sequence_initialized_by_subaccount[subaccount] = False\n                continue\n            sequence_account = cast(SequenceAccount, sequence_account_raw)\n            self.sequence_number_by_subaccount[subaccount] = (\n                sequence_account.sequence_num + 1\n            )\n            self.sequence_bump_by_subaccount[subaccount] = bump\n            self.sequence_initialized_by_subaccount[subaccount] = True\n            self.sequence_address_by_subaccount[subaccount] = address\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.__init__","title":"<code>__init__(connection, wallet, env='mainnet', opts=DEFAULT_TX_OPTIONS, authority=None, account_subscription=AccountSubscriptionConfig.default(), perp_market_indexes=None, spot_market_indexes=None, oracle_infos=None, tx_params=None, tx_version=None, tx_sender=None, active_sub_account_id=None, sub_account_ids=None, market_lookup_table=None, jito_params=None, enforce_tx_sequencing=False)</code>","text":"<p>Initializes the drift client object</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>Drift anchor program (see from_config on how to initialize it)</p> required <code>authority</code> <code>Keypair</code> <p>Authority of all txs - if None will default to the Anchor Provider.Wallet Keypair.</p> <code>None</code> Source code in <code>driftpy/drift_client.py</code> <pre><code>def __init__(\n    self,\n    connection: AsyncClient,\n    wallet: Union[Keypair, Wallet],\n    env: DriftEnv = \"mainnet\",\n    opts: TxOpts = DEFAULT_TX_OPTIONS,\n    authority: Pubkey = None,\n    account_subscription: Optional[\n        AccountSubscriptionConfig\n    ] = AccountSubscriptionConfig.default(),\n    perp_market_indexes: list[int] = None,\n    spot_market_indexes: list[int] = None,\n    oracle_infos: list[OracleInfo] = None,\n    tx_params: Optional[TxParams] = None,\n    tx_version: Optional[TransactionVersion] = None,\n    tx_sender: TxSender = None,\n    active_sub_account_id: Optional[int] = None,\n    sub_account_ids: Optional[list[int]] = None,\n    market_lookup_table: Optional[Pubkey] = None,\n    jito_params: Optional[JitoParams] = None,\n    enforce_tx_sequencing: bool = False,\n):\n    \"\"\"Initializes the drift client object\n\n    Args:\n        program (Program): Drift anchor program (see from_config on how to initialize it)\n        authority (Keypair, optional): Authority of all txs - if None will default to the Anchor Provider.Wallet Keypair.\n    \"\"\"\n    self.connection = connection\n\n    file = Path(str(driftpy.__path__[0]) + \"/idl/drift.json\")\n    with file.open() as f:\n        raw = file.read_text()\n    idl = Idl.from_json(raw)\n\n    provider = Provider(connection, wallet, opts)\n    self.program_id = DRIFT_PROGRAM_ID\n    self.program = Program(\n        idl,\n        self.program_id,\n        provider,\n    )\n\n    if isinstance(wallet, Keypair):\n        wallet = Wallet(wallet)\n\n    if authority is None:\n        authority = wallet.public_key\n\n    self.wallet = wallet\n    self.authority = authority\n\n    self.active_sub_account_id = (\n        active_sub_account_id if active_sub_account_id is not None else 0\n    )\n    self.sub_account_ids = (\n        sub_account_ids\n        if sub_account_ids is not None\n        else [self.active_sub_account_id]\n    )\n    self.users = {}\n\n    self.last_perp_market_seen_cache = {}\n    self.last_spot_market_seen_cache = {}\n\n    self.account_subscriber = account_subscription.get_drift_client_subscriber(\n        self.program, perp_market_indexes, spot_market_indexes, oracle_infos\n    )\n    self.account_subscription_config = account_subscription\n\n    self.market_lookup_table = (\n        market_lookup_table\n        if market_lookup_table is not None\n        else configs[env].market_lookup_table\n    )\n    self.market_lookup_table_account: Optional[AddressLookupTableAccount] = None\n\n    if tx_params is None:\n        tx_params = TxParams(600_000, 0)\n\n    self.tx_params = tx_params\n\n    self.tx_version = tx_version if tx_version is not None else Legacy\n\n    self.enforce_tx_sequencing = enforce_tx_sequencing\n    if self.enforce_tx_sequencing is True:\n        file = Path(str(driftpy.__path__[0]) + \"/idl/sequence_enforcer.json\")\n        with file.open() as f:\n            raw = file.read_text()\n        idl = Idl.from_json(raw)\n\n        provider = Provider(connection, wallet, opts)\n        self.sequence_enforcer_pid = (\n            SEQUENCER_PROGRAM_ID\n            if env == \"mainnet\"\n            else DEVNET_SEQUENCER_PROGRAM_ID\n        )\n        self.sequence_enforcer_program = Program(\n            idl,\n            self.sequence_enforcer_pid,\n            provider,\n        )\n        self.sequence_number_by_subaccount = {}\n        self.sequence_bump_by_subaccount = {}\n        self.sequence_initialized_by_subaccount = {}\n        self.sequence_address_by_subaccount = {}\n        self.resetting_sequence = False\n\n    if jito_params is not None:\n        from driftpy.tx.jito_tx_sender import JitoTxSender\n\n        self.tx_sender = JitoTxSender(\n            self,\n            opts,\n            jito_params.block_engine_url,\n            jito_params.jito_keypair,\n            blockhash_refresh_interval_secs=jito_params.blockhash_refresh_rate,\n            tip_amount=jito_params.tip_amount,\n        )\n    else:\n        self.tx_sender = (\n            StandardTxSender(self.connection, opts)\n            if tx_sender is None\n            else tx_sender\n        )\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.add_liquidity","title":"<code>add_liquidity(amount, market_index, sub_account_id=None)</code>  <code>async</code>","text":"<p>mint LP tokens and add liquidity to the DAMM</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount of lp tokens to mint</p> required <code>market_index</code> <code>int</code> <p>market you want to lp in</p> required <code>sub_account_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def add_liquidity(\n    self, amount: int, market_index: int, sub_account_id: int = None\n):\n    \"\"\"mint LP tokens and add liquidity to the DAMM\n\n    Args:\n        amount (int): amount of lp tokens to mint\n        market_index (int): market you want to lp in\n        sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    tx_sig_and_slot = await self.send_ixs(\n        [self.get_add_liquidity_ix(amount, market_index, sub_account_id)]\n    )\n\n    self.last_perp_market_seen_cache[market_index] = tx_sig_and_slot.slot\n\n    return tx_sig_and_slot.tx_sig\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.cancel_order","title":"<code>cancel_order(order_id=None, sub_account_id=None)</code>  <code>async</code>","text":"<p>cancel specific order (if order_id=None will be most recent order)</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>Optional[int]</code> <p>Defaults to None.</p> <code>None</code> <code>sub_account_id</code> <code>int</code> <p>subaccount id which contains order. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def cancel_order(\n    self,\n    order_id: Optional[int] = None,\n    sub_account_id: int = None,\n):\n    \"\"\"cancel specific order (if order_id=None will be most recent order)\n\n    Args:\n        order_id (Optional[int], optional): Defaults to None.\n        sub_account_id (int, optional): subaccount id which contains order. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return (\n        await self.send_ixs(\n            self.get_cancel_order_ix(order_id, sub_account_id),\n        )\n    ).tx_sig\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.cancel_orders","title":"<code>cancel_orders(market_type=None, market_index=None, direction=None, sub_account_id=None)</code>  <code>async</code>","text":"<p>cancel all existing orders on the book</p> <p>Parameters:</p> Name Type Description Default <code>market_type</code> <code>MarketType</code> <p>only cancel orders for single market, used with market_index</p> <code>None</code> <code>market_index</code> <code>int</code> <p>only cancel orders for single market, used with market_type</p> <code>None</code> <code>direction</code> <code>PositionDirection</code> <p>(PositionDirection, optional): only cancel bids or asks</p> <code>None</code> <code>sub_account_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def cancel_orders(\n    self,\n    market_type: MarketType = None,\n    market_index: int = None,\n    direction: PositionDirection = None,\n    sub_account_id: int = None,\n):\n    \"\"\"cancel all existing orders on the book\n\n    Args:\n        market_type (MarketType, optional): only cancel orders for single market, used with market_index\n        market_index (int, optional): only cancel orders for single market, used with market_type\n        direction: (PositionDirection, optional): only cancel bids or asks\n        sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return (\n        await self.send_ixs(\n            self.get_cancel_orders_ix(\n                market_type, market_index, direction, sub_account_id\n            )\n        )\n    ).tx_sig\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.deposit","title":"<code>deposit(amount, spot_market_index, user_token_account=None, sub_account_id=None, reduce_only=False, user_initialized=True)</code>  <code>async</code>","text":"<p>deposits collateral into protocol</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to deposit</p> required <code>spot_market_index</code> <code>int</code> required <code>user_token_account</code> <code>Pubkey</code> <code>None</code> <code>sub_account_id</code> <code>int</code> <p>subaccount to deposit into. Defaults to 0.</p> <code>None</code> <code>reduce_only</code> <code>bool</code> <p>paying back borrow vs depositing new assets. Defaults to False.</p> <code>False</code> <code>user_initialized</code> <code>bool</code> <p>if need to initialize user account too set this to False. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <p>sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def deposit(\n    self,\n    amount: int,\n    spot_market_index: int,\n    user_token_account: Pubkey = None,\n    sub_account_id: int = None,\n    reduce_only=False,\n    user_initialized=True,\n):\n    \"\"\"deposits collateral into protocol\n\n    Args:\n        amount (int): amount to deposit\n        spot_market_index (int):\n        user_token_account (Pubkey):\n        sub_account_id (int, optional): subaccount to deposit into. Defaults to 0.\n        reduce_only (bool, optional): paying back borrow vs depositing new assets. Defaults to False.\n        user_initialized (bool, optional): if need to initialize user account too set this to False. Defaults to True.\n\n    Returns:\n        str: sig\n    \"\"\"\n    tx_sig_and_slot = await self.send_ixs(\n        [\n            self.get_deposit_collateral_ix(\n                amount,\n                spot_market_index,\n                user_token_account,\n                sub_account_id,\n                reduce_only,\n                user_initialized,\n            )\n        ]\n    )\n    self.last_spot_market_seen_cache[spot_market_index] = tx_sig_and_slot.slot\n    return tx_sig_and_slot\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.get_market_index_and_type","title":"<code>get_market_index_and_type(name)</code>","text":"<p>Returns the market index and type for a given market name </p> <p>Returns <code>None</code> if the market name couldn't be matched </p> <p>e.g. \"SOL-PERP\" -&gt; <code>(0, MarketType.Perp())</code></p> Source code in <code>driftpy/drift_client.py</code> <pre><code>def get_market_index_and_type(\n    self, name: str\n) -&gt; Union[Tuple[int, MarketType], None]:\n    \"\"\"\n    Returns the market index and type for a given market name \\n\n    Returns `None` if the market name couldn't be matched \\n\n    e.g. \"SOL-PERP\" -&gt; `(0, MarketType.Perp())`\n    \"\"\"\n    name = name.upper()\n    for perp_market_account in self.get_perp_market_accounts():\n        if decode_name(perp_market_account.name).upper() == name:\n            return (perp_market_account.market_index, MarketType.Perp())\n\n    for spot_market_account in self.get_spot_market_accounts():\n        if decode_name(spot_market_account.name).upper() == name:\n            return (spot_market_account.market_index, MarketType.Spot())\n\n    return None  # explicitly return None if no match is found\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.initialize_user","title":"<code>initialize_user(sub_account_id=0, name=None, referrer_info=None)</code>  <code>async</code>","text":"<p>intializes a drift user</p> <p>Parameters:</p> Name Type Description Default <code>sub_account_id</code> <code>int</code> <p>subaccount id to initialize. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx signature</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def initialize_user(\n    self,\n    sub_account_id: int = 0,\n    name: str = None,\n    referrer_info: ReferrerInfo = None,\n):\n    \"\"\"intializes a drift user\n\n    Args:\n        sub_account_id (int, optional): subaccount id to initialize. Defaults to 0.\n\n    Returns:\n        str: tx signature\n    \"\"\"\n    ixs = []\n    if sub_account_id == 0:\n        ixs.append(self.get_initialize_user_stats())\n        if name is None:\n            name = DEFAULT_USER_NAME\n\n    if name is None:\n        name = \"Subaccount \" + str(sub_account_id + 1)\n\n    ix = self.get_initialize_user_instructions(sub_account_id, name, referrer_info)\n    ixs.append(ix)\n    return (await self.send_ixs(ixs)).tx_sig\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.remove_liquidity","title":"<code>remove_liquidity(amount, market_index, sub_account_id=None)</code>  <code>async</code>","text":"<p>burns LP tokens and removes liquidity to the DAMM</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount of lp tokens to burn</p> required <code>market_index</code> <code>int</code> required <code>sub_account_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def remove_liquidity(\n    self, amount: int, market_index: int, sub_account_id: int = None\n):\n    \"\"\"burns LP tokens and removes liquidity to the DAMM\n\n    Args:\n        amount (int): amount of lp tokens to burn\n        market_index (int):\n        sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return (\n        await self.send_ixs(\n            [self.get_remove_liquidity_ix(amount, market_index, sub_account_id)]\n        )\n    ).tx_sig\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.update_user_margin_trading_enabled","title":"<code>update_user_margin_trading_enabled(margin_trading_enabled, sub_account_id=None)</code>  <code>async</code>","text":"<p>Toggles margin trading for a user</p> <p>Parameters:</p> Name Type Description Default <code>sub_account_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def update_user_margin_trading_enabled(\n    self, margin_trading_enabled: bool, sub_account_id: Optional[int] = None\n):\n    \"\"\"Toggles margin trading for a user\n\n    Args:\n        sub_account_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    await self.add_user(sub_account_id)\n\n    tx_sig = await self.send_ixs(\n        [\n            self.get_update_user_margin_trading_enabled_ix(\n                margin_trading_enabled=margin_trading_enabled,\n                sub_account_id=sub_account_id,\n            )\n        ]\n    ).tx_sig\n    return tx_sig\n</code></pre>"},{"location":"clearing_house/#driftpy.drift_client.DriftClient.withdraw","title":"<code>withdraw(amount, market_index, user_token_account, reduce_only=False, sub_account_id=None)</code>  <code>async</code>","text":"<p>withdraws from drift protocol (can also allow borrowing)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to withdraw</p> required <code>market_index</code> <code>int</code> required <code>user_token_account</code> <code>Pubkey</code> <p>ata of the account to withdraw to</p> required <code>reduce_only</code> <code>bool</code> <p>if True will only withdraw existing funds else if False will allow taking out borrows. Defaults to False.</p> <code>False</code> <code>sub_account_id</code> <code>int</code> <p>subaccount. Defaults to 0.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>driftpy/drift_client.py</code> <pre><code>async def withdraw(\n    self,\n    amount: int,\n    market_index: int,\n    user_token_account: Pubkey,\n    reduce_only: bool = False,\n    sub_account_id: int = None,\n):\n    \"\"\"withdraws from drift protocol (can also allow borrowing)\n\n    Args:\n        amount (int): amount to withdraw\n        market_index (int):\n        user_token_account (Pubkey): ata of the account to withdraw to\n        reduce_only (bool, optional): if True will only withdraw existing funds else if False will allow taking out borrows. Defaults to False.\n        sub_account_id (int, optional): subaccount. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    tx_sig_and_slot = await self.send_ixs(\n        [\n            self.get_withdraw_collateral_ix(\n                amount,\n                market_index,\n                user_token_account,\n                reduce_only,\n                sub_account_id,\n            )\n        ]\n    )\n    self.last_spot_market_seen_cache[market_index] = tx_sig_and_slot.slot\n    return tx_sig_and_slot\n</code></pre>"},{"location":"clearing_house_user/","title":"User","text":"<p>This object is used to fetch data from the protocol and view user metrics (leverage, free collateral, etc.)</p>"},{"location":"clearing_house_user/#example","title":"Example","text":"<pre><code>drift_client = DriftClient.from_config(config, provider)\ndrift_user = User(drift_client)\n\n# inspect user's leverage\nleverage = await drift_user.get_leverage()\nprint('current leverage:', leverage / 10_000)\n\n# you can also inspect other accounts information using the (authority=) flag\nbigz_acc = User(drift_client, authority=PublicKey('bigZ'))\nleverage = await bigz_acc.get_leverage()\nprint('bigZs leverage:', leverage / 10_000)\n\n# user calls can be expensive on the rpc so we can cache them\ndrift_user = User(drift_client, use_cache=True)\nawait drift_user.set_cache()\n\n# works without any rpc calls (uses the cached data)\nupnl = await drift_user.get_unrealized_pnl(with_funding=True)\nprint('upnl:', upnl)\n</code></pre>"},{"location":"clearing_house_user/#driftpy.drift_user.DriftUser","title":"<code>DriftUser</code>","text":"<p>This class is the main way to retrieve and inspect drift user account data.</p> Source code in <code>driftpy/drift_user.py</code> <pre><code>class DriftUser:\n    \"\"\"This class is the main way to retrieve and inspect drift user account data.\"\"\"\n\n    def __init__(\n        self,\n        drift_client,\n        user_public_key: Pubkey,\n        account_subscription: Optional[\n            AccountSubscriptionConfig\n        ] = AccountSubscriptionConfig.default(),\n    ):\n        \"\"\"Initialize the user object\n\n        Args:\n            drift_client(DriftClient): required for program_id, idl, things (keypair doesnt matter)\n            user_public_key (Pubkey): pubkey for user account\n            account_subscription (Optional[AccountSubscriptionConfig], optional): method of receiving account updates\n        \"\"\"\n        from driftpy.drift_client import DriftClient\n\n        self.drift_client: DriftClient = drift_client\n        self.program = drift_client.program\n        self.oracle_program = drift_client\n        self.connection = self.program.provider.connection\n\n        self.user_public_key = user_public_key\n\n        self.account_subscriber = account_subscription.get_user_client_subscriber(\n            self.program, self.user_public_key\n        )\n\n    async def subscribe(self):\n        await self.account_subscriber.subscribe()\n\n    def unsubscribe(self):\n        self.account_subscriber.unsubscribe()\n\n    def get_oracle_data_for_spot_market(\n        self, market_index: int\n    ) -&gt; Optional[OraclePriceData]:\n        return self.drift_client.get_oracle_price_data_for_spot_market(market_index)\n\n    def get_oracle_data_for_perp_market(\n        self, market_index: int\n    ) -&gt; Optional[OraclePriceData]:\n        return self.drift_client.get_oracle_price_data_for_perp_market(market_index)\n\n    def get_perp_market_account(self, market_index: int) -&gt; PerpMarketAccount:\n        return self.drift_client.get_perp_market_account(market_index)\n\n    def get_spot_market_account(self, market_index: int) -&gt; SpotMarketAccount:\n        return self.drift_client.get_spot_market_account(market_index)\n\n    def get_user_account_and_slot(self) -&gt; DataAndSlot[UserAccount]:\n        return self.account_subscriber.get_user_account_and_slot()\n\n    def get_user_account(self) -&gt; UserAccount:\n        return self.account_subscriber.get_user_account_and_slot().data\n\n    def get_token_amount(self, market_index: int) -&gt; int:\n        spot_position = self.get_spot_position(market_index)\n        if spot_position is None:\n            return 0\n\n        spot_market = self.get_spot_market_account(market_index)\n        token_amount = get_token_amount(\n            spot_position.scaled_balance, spot_market, spot_position.balance_type\n        )\n        return get_signed_token_amount(token_amount, spot_position.balance_type)\n\n    def get_order(self, order_id: int) -&gt; Optional[Order]:\n        for order in self.get_user_account().orders:\n            if order.order_id == order_id:\n                return order\n\n        return None\n\n    def get_order_by_user_order_id(self, user_order_id: int):\n        for order in self.get_user_account().orders:\n            if order.user_order_id == user_order_id:\n                return order\n\n        return None\n\n    def get_open_orders(\n        self,\n    ):\n        return list(\n            filter(\n                lambda order: \"Open\" in str(order.status),\n                self.get_user_account().orders,\n            )\n        )\n\n    def get_perp_position(self, market_index: int) -&gt; Optional[PerpPosition]:\n        for position in self.get_user_account().perp_positions:\n            if position.market_index == market_index and not is_available(position):\n                return position\n\n        return None\n\n    def get_spot_position(self, market_index: int) -&gt; Optional[SpotPosition]:\n        for position in self.get_user_account().spot_positions:\n            if (\n                position.market_index == market_index\n                and not is_spot_position_available(position)\n            ):\n                return position\n\n        return None\n\n    def get_perp_market_liability(\n        self,\n        market_index: int = None,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = 0,\n        include_open_orders: bool = False,\n        signed: bool = False,\n    ):\n        user = self.get_user_account()\n\n        total_liability_value = 0\n        for position in user.perp_positions:\n            if market_index is not None and market_index != position.market_index:\n                continue\n\n            if position.lp_shares &gt; 0:\n                continue\n\n            market = self.drift_client.get_perp_market_account(position.market_index)\n\n            price = (self.get_oracle_data_for_perp_market(position.market_index)).price\n            base_asset_amount = (\n                calculate_worst_case_base_asset_amount(position)\n                if include_open_orders\n                else position.base_asset_amount\n            )\n            base_value = (\n                ((base_asset_amount) if signed else abs(base_asset_amount))\n                * price\n                / (AMM_TO_QUOTE_PRECISION_RATIO * PRICE_PRECISION)\n            )\n\n            if margin_category is not None:\n                margin_ratio = calculate_market_margin_ratio(\n                    market, abs(base_asset_amount), margin_category\n                )\n\n                if margin_category == MarginCategory.INITIAL:\n                    margin_ratio = max(margin_ratio, user.max_margin_ratio)\n\n                if liquidation_buffer is not None:\n                    margin_ratio += liquidation_buffer\n\n                base_value = base_value * margin_ratio / MARGIN_PRECISION\n\n            total_liability_value += base_value\n        return total_liability_value\n\n    def is_being_liquidated(self) -&gt; bool:\n        user_account = self.get_user_account()\n        return (\n            user_account.status &amp; (UserStatus.BEING_LIQUIDATED | UserStatus.BANKRUPT)\n        ) &gt; 0\n\n    def can_be_liquidated(self) -&gt; bool:\n        total_collateral = self.get_total_collateral()\n\n        user = self.get_user_account()\n        liquidation_buffer = None\n        if self.is_being_liquidated():\n            liquidation_buffer = (\n                self.drift_client.get_state_account()\n            ).liquidation_margin_buffer_ratio\n\n        maintenance_req = self.get_margin_requirement(\n            MarginCategory.MAINTENANCE, liquidation_buffer\n        )\n\n        return total_collateral &lt; maintenance_req\n\n    def get_margin_requirement(\n        self,\n        margin_category: MarginCategory = MarginCategory.INITIAL,\n        liquidation_buffer: Optional[int] = 0,\n        strict: bool = False,\n    ) -&gt; int:\n        total_perp_pos_value = self.get_total_perp_position_value(\n            margin_category, liquidation_buffer, True, strict\n        )\n        spot_market_liab_value = self.get_spot_market_liability_value(\n            None, margin_category, liquidation_buffer, True, strict\n        )\n\n        return total_perp_pos_value + spot_market_liab_value\n\n    def get_total_perp_position_value(\n        self,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = None,\n        include_open_orders: Optional[bool] = False,\n        strict: bool = False,\n    ) -&gt; int:\n        total_perp_value = 0\n        for perp_position in self.get_active_perp_positions():\n            base_asset_value = self.calculate_weighted_perp_position_value(\n                perp_position,\n                margin_category,\n                liquidation_buffer,\n                include_open_orders,\n                strict,\n            )\n            total_perp_value += base_asset_value\n\n        return total_perp_value\n\n    def calculate_weighted_perp_position_value(\n        self,\n        perp_position: PerpPosition,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = None,\n        include_open_orders: Optional[bool] = False,\n        strict: bool = False,\n    ) -&gt; int:\n        market = self.drift_client.get_perp_market_account(perp_position.market_index)\n\n        if perp_position.lp_shares &gt; 0:\n            perp_position = self.get_perp_position_with_lp_settle(\n                market.market_index,\n                copy.deepcopy(perp_position),\n                margin_category is not None,\n            )[0]\n\n        valuation_price = self.get_oracle_data_for_perp_market(\n            market.market_index\n        ).price\n\n        if is_variant(market.status, \"Settlement\"):\n            valuation_price = market.expiry_price\n\n        base_asset_amount = (\n            calculate_worst_case_base_asset_amount(perp_position)\n            if include_open_orders\n            else perp_position.base_asset_amount\n        )\n\n        base_asset_value = (abs(base_asset_amount) * valuation_price) // BASE_PRECISION\n\n        if margin_category is not None:\n            margin_ratio = calculate_market_margin_ratio(\n                market,\n                abs(base_asset_amount),\n                margin_category,\n                self.get_user_account().max_margin_ratio,\n            )\n\n            if liquidation_buffer is not None:\n                margin_ratio += liquidation_buffer\n\n            if is_variant(market.status, \"Settlement\"):\n                margin_ratio = 0\n\n            quote_spot_market = self.drift_client.get_spot_market_account(\n                market.quote_spot_market_index\n            )\n\n            quote_oracle_price_data = self.get_oracle_data_for_spot_market(\n                QUOTE_SPOT_MARKET_INDEX\n            )\n\n            if strict:\n                quote_price = max(\n                    quote_oracle_price_data.price,\n                    quote_spot_market.historical_oracle_data.last_oracle_price_twap5min,\n                )\n            else:\n                quote_price = quote_oracle_price_data.price\n\n            base_asset_value = (\n                ((base_asset_value * quote_price) // PRICE_PRECISION) * margin_ratio\n            ) // MARGIN_PRECISION\n\n            if include_open_orders:\n                base_asset_value += (\n                    perp_position.open_orders * OPEN_ORDER_MARGIN_REQUIREMENT\n                )\n\n                if perp_position.lp_shares &gt; 0:\n                    base_asset_value += max(\n                        QUOTE_PRECISION,\n                        (\n                            (\n                                valuation_price\n                                * market.amm.order_step_size\n                                * QUOTE_PRECISION\n                            )\n                            // AMM_RESERVE_PRECISION\n                        )\n                        // PRICE_PRECISION,\n                    )\n\n        return base_asset_value\n\n    def get_active_perp_positions(self) -&gt; list[PerpPosition]:\n        user = self.get_user_account()\n        return self.get_active_perp_positions_for_user_account(user)\n\n    def get_active_perp_positions_for_user_account(\n        self, user: UserAccount\n    ) -&gt; list[PerpPosition]:\n        return [\n            pos\n            for pos in user.perp_positions\n            if pos.base_asset_amount != 0\n            or pos.quote_asset_amount != 0\n            or pos.open_orders != 0\n            or pos.lp_shares != 0\n        ]\n\n    def get_total_collateral(\n        self,\n        margin_category: Optional[MarginCategory] = MarginCategory.INITIAL,\n        strict: bool = False,\n    ) -&gt; int:\n        asset_value = self.get_spot_market_asset_value(\n            margin_category=margin_category, include_open_orders=True, strict=strict\n        )\n        pnl = self.get_unrealized_pnl(True, with_weight_margin_category=margin_category)\n        total_collateral = asset_value + pnl\n        return total_collateral\n\n    def get_free_collateral(\n        self, margin_category: MarginCategory = MarginCategory.INITIAL\n    ):\n        total_collateral = self.get_total_collateral(margin_category, True)\n        if margin_category == MarginCategory.INITIAL:\n            margin_req = self.get_margin_requirement(margin_category, strict=True)\n        else:\n            margin_req = self.get_margin_requirement(margin_category)\n        free_collateral = total_collateral - margin_req\n        free_collateral = max(0, free_collateral)\n        return free_collateral\n\n    def get_user_spot_position(\n        self,\n        market_index: int,\n    ) -&gt; Optional[SpotPosition]:\n        user = self.get_user_account()\n\n        found = False\n        for position in user.spot_positions:\n            if (\n                position.market_index == market_index\n                and not is_spot_position_available(position)\n            ):\n                found = True\n                break\n\n        if not found:\n            return None\n\n        return position\n\n    def get_user_position(\n        self,\n        market_index: int,\n    ) -&gt; Optional[PerpPosition]:\n        user = self.get_user_account()\n\n        found = False\n        for position in user.perp_positions:\n            if position.market_index == market_index and not is_available(position):\n                found = True\n                break\n\n        if not found:\n            return None\n\n        return position\n\n    def get_health(self) -&gt; int:\n        if self.is_being_liquidated():\n            return 0\n\n        total_collateral = self.get_total_collateral(MarginCategory.MAINTENANCE)\n        maintenance_margin_req = self.get_margin_requirement(MarginCategory.MAINTENANCE)\n\n        if maintenance_margin_req == 0 and total_collateral &gt;= 0:\n            return 100\n        elif total_collateral &lt;= 0:\n            return 0\n        else:\n            return round(\n                min(100, max(0, (1 - maintenance_margin_req / total_collateral) * 100))\n            )\n\n    def get_unrealized_pnl(\n        self,\n        with_funding: bool = False,\n        market_index: int = None,\n        with_weight_margin_category: Optional[MarginCategory] = None,\n        strict: bool = False,\n    ):\n        user = self.get_user_account()\n        quote_spot_market = self.drift_client.get_spot_market_account(\n            QUOTE_SPOT_MARKET_INDEX\n        )\n\n        unrealized_pnl = 0\n        for position in user.perp_positions:\n            if market_index is not None and position.market_index != market_index:\n                continue\n\n            market = self.drift_client.get_perp_market_account(position.market_index)\n\n            oracle_price_data = self.get_oracle_data_for_perp_market(\n                market.market_index\n            )\n\n            quote_oracle_price_data = self.get_oracle_data_for_spot_market(\n                quote_spot_market.market_index\n            )\n\n            if position.lp_shares &gt; 0:\n                position = self.get_perp_position_with_lp_settle(\n                    position.market_index, None, bool(with_weight_margin_category)\n                )[0]\n\n            position_upnl = calculate_position_pnl(\n                market, position, oracle_price_data, with_funding\n            )\n\n            if strict and position_upnl &gt; 0:\n                quote_price = min(\n                    quote_oracle_price_data.price,\n                    quote_spot_market.historical_oracle_data.last_oracle_price_twap5min,\n                )\n            elif strict and position_upnl &lt; 0:\n                quote_price = max(\n                    quote_oracle_price_data.price,\n                    quote_spot_market.historical_oracle_data.last_oracle_price_twap5min,\n                )\n            else:\n                quote_price = quote_oracle_price_data.price\n\n            position_upnl = (position_upnl * quote_price) // PRICE_PRECISION\n\n            if with_weight_margin_category:\n                if position_upnl &gt; 0:\n                    position_upnl = position_upnl * (\n                        calculate_unrealized_asset_weight(\n                            market,\n                            quote_spot_market,\n                            position_upnl,\n                            with_weight_margin_category,\n                            oracle_price_data,\n                        )\n                    )\n                    position_upnl = position_upnl // SPOT_MARKET_WEIGHT_PRECISION\n\n            unrealized_pnl += position_upnl\n\n        return unrealized_pnl\n\n    def get_unrealized_funding_pnl(\n        self,\n        market_index: int = None,\n    ):\n        user = self.get_user_account()\n\n        unrealized_pnl = 0\n        for position in user.perp_positions:\n            if market_index is not None and position.market_index != market_index:\n                continue\n\n            perp_market = self.drift_client.get_perp_market_account(\n                position.market_index\n            )\n\n            unrealized_pnl += calculate_position_funding_pnl(perp_market, position)\n\n        return unrealized_pnl\n\n    def get_spot_market_asset_and_liability_value(\n        self,\n        market_index: Optional[int] = None,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = None,\n        include_open_orders: bool = True,\n        strict: bool = False,\n        now: Optional[int] = None,\n    ) -&gt; (int, int):\n        now = now or int(time.time())\n        net_quote_value = 0\n        total_asset_value = 0\n        total_liability_value = 0\n        for spot_position in self.get_user_account().spot_positions:\n            count_for_base = (\n                market_index is None or market_index == spot_position.market_index\n            )\n            count_for_quote = (\n                market_index is None\n                or market_index == QUOTE_SPOT_MARKET_INDEX\n                or (include_open_orders and spot_position.open_orders != 0)\n            )\n\n            if is_spot_position_available(spot_position) or (\n                not count_for_base and not count_for_quote\n            ):\n                continue\n\n            spot_market_account = self.drift_client.get_spot_market_account(\n                spot_position.market_index\n            )\n            oracle_price_data = self.get_oracle_data_for_spot_market(\n                spot_position.market_index\n            )\n\n            twap_5m = None\n            if strict:\n                twap_5m = calculate_live_oracle_twap(\n                    spot_market_account.historical_oracle_data,\n                    oracle_price_data,\n                    now,\n                    FIVE_MINUTE,\n                )\n\n            strict_oracle_price = StrictOraclePrice(oracle_price_data.price, twap_5m)\n\n            if (\n                spot_position.market_index == QUOTE_SPOT_MARKET_INDEX\n                and count_for_quote\n            ):\n                token_amount = get_signed_token_amount(\n                    get_token_amount(\n                        spot_position.scaled_balance,\n                        spot_market_account,\n                        spot_position.balance_type,\n                    ),\n                    spot_position.balance_type,\n                )\n                if is_variant(spot_position.balance_type, \"Borrow\"):\n                    weighted_token_value = abs(\n                        self.get_spot_liability_value(\n                            token_amount,\n                            strict_oracle_price,\n                            spot_market_account,\n                            margin_category,\n                            liquidation_buffer,\n                        )\n                    )\n                    net_quote_value -= weighted_token_value\n                else:\n                    weighted_token_value = self.get_spot_asset_value(\n                        token_amount,\n                        strict_oracle_price,\n                        spot_market_account,\n                        margin_category,\n                    )\n                    net_quote_value += weighted_token_value\n                continue\n\n            if not include_open_orders and count_for_base:\n                if is_variant(spot_position.balance_type, \"Borrow\"):\n                    token_amount = get_signed_token_amount(\n                        get_token_amount(\n                            spot_position.scaled_balance,\n                            spot_market_account,\n                            spot_position.balance_type,\n                        ),\n                        \"Borrow\",\n                    )\n                    liability_value = abs(\n                        self.get_spot_liability_value(\n                            token_amount,\n                            strict_oracle_price,\n                            spot_market_account,\n                            margin_category,\n                            liquidation_buffer,\n                        )\n                    )\n                    total_liability_value += liability_value\n                else:\n                    token_amount = get_token_amount(\n                        spot_position.scaled_balance,\n                        spot_market_account,\n                        spot_position.balance_type,\n                    )\n                    asset_value = self.get_spot_asset_value(\n                        token_amount,\n                        strict_oracle_price,\n                        spot_market_account,\n                        margin_category,\n                    )\n                    total_asset_value += asset_value\n                continue\n\n            order_fill_simulation = get_worst_case_token_amounts(\n                spot_position,\n                spot_market_account,\n                strict_oracle_price,\n                margin_category,\n                self.get_user_account().max_margin_ratio,\n            )\n            worst_case_token_amount = order_fill_simulation.token_amount\n            worst_case_quote_token_amount = order_fill_simulation.orders_value\n\n            if worst_case_token_amount &gt; 0 and count_for_base:\n                base_asset_value = self.get_spot_asset_value(\n                    worst_case_token_amount,\n                    strict_oracle_price,\n                    spot_market_account,\n                    margin_category,\n                )\n                total_asset_value += base_asset_value\n\n            if worst_case_token_amount &lt; 0 and count_for_base:\n                base_liability_value = abs(\n                    self.get_spot_liability_value(\n                        worst_case_token_amount,\n                        strict_oracle_price,\n                        spot_market_account,\n                        margin_category,\n                        liquidation_buffer,\n                    )\n                )\n                total_liability_value += base_liability_value\n\n            if worst_case_quote_token_amount &gt; 0 and count_for_quote:\n                net_quote_value += worst_case_quote_token_amount\n\n            if worst_case_quote_token_amount &lt; 0 and count_for_quote:\n                weight = SPOT_MARKET_WEIGHT_PRECISION\n                if margin_category == MarginCategory.INITIAL:\n                    weight = max(weight, self.get_user_account().max_margin_ratio)\n                weighted_token_value = (\n                    abs(worst_case_quote_token_amount)\n                    * weight\n                    // SPOT_MARKET_WEIGHT_PRECISION\n                )\n                net_quote_value -= weighted_token_value\n\n            total_liability_value += (\n                spot_position.open_orders * OPEN_ORDER_MARGIN_REQUIREMENT\n            )\n\n        if market_index is None or market_index == QUOTE_SPOT_MARKET_INDEX:\n            if net_quote_value &gt; 0:\n                total_asset_value += net_quote_value\n            else:\n                total_liability_value += abs(net_quote_value)\n\n        return total_asset_value, total_liability_value\n\n    def get_spot_asset_value(\n        self,\n        token_amount: int,\n        strict_oracle_price: StrictOraclePrice,\n        spot_market_account: SpotMarketAccount,\n        margin_category: Optional[MarginCategory] = None,\n    ) -&gt; int:\n        asset_value = get_strict_token_value(\n            token_amount, spot_market_account.decimals, strict_oracle_price\n        )\n\n        if margin_category is not None:\n            weight = calculate_asset_weight(\n                token_amount,\n                strict_oracle_price.current,\n                spot_market_account,\n                margin_category,\n            )\n\n            if (\n                margin_category == MarginCategory.INITIAL\n                and spot_market_account.market_index != QUOTE_SPOT_MARKET_INDEX\n            ):\n                user_custom_asset_weight = max(\n                    0,\n                    SPOT_MARKET_WEIGHT_PRECISION\n                    - self.get_user_account().max_margin_ratio,\n                )\n                weight = min(weight, user_custom_asset_weight)\n\n            asset_value = (asset_value * weight) // SPOT_MARKET_WEIGHT_PRECISION\n\n        return asset_value\n\n    def get_spot_liability_value(\n        self,\n        token_amount: int,\n        strict_oracle_price: StrictOraclePrice,\n        spot_market_account: SpotMarketAccount,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = None,\n    ) -&gt; int:\n        liability_value = get_strict_token_value(\n            token_amount, spot_market_account.decimals, strict_oracle_price\n        )\n\n        if margin_category is not None:\n            weight = calculate_liability_weight(\n                token_amount, spot_market_account, margin_category\n            )\n\n            if (\n                margin_category == MarginCategory.INITIAL\n                and spot_market_account.market_index != QUOTE_SPOT_MARKET_INDEX\n            ):\n                weight = max(\n                    weight,\n                    SPOT_MARKET_WEIGHT_PRECISION\n                    + self.get_user_account().max_margin_ratio,\n                )\n\n            if liquidation_buffer is not None:\n                weight += liquidation_buffer\n\n            liability_value = (liability_value * weight) // SPOT_MARKET_WEIGHT_PRECISION\n\n        return liability_value\n\n    def get_spot_market_asset_value(\n        self,\n        market_index: Optional[int] = None,\n        margin_category: Optional[MarginCategory] = None,\n        include_open_orders: bool = True,\n        strict: bool = False,\n        now: Optional[int] = None,\n    ):\n        asset_value, _ = self.get_spot_market_asset_and_liability_value(\n            market_index,\n            margin_category,\n            include_open_orders=include_open_orders,\n            strict=strict,\n            now=now,\n        )\n        return asset_value\n\n    def get_spot_market_liability_value(\n        self,\n        market_index: Optional[int] = None,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = None,\n        include_open_orders: bool = True,\n        strict: bool = False,\n        now: Optional[int] = None,\n    ):\n        _, total_liability_value = self.get_spot_market_asset_and_liability_value(\n            market_index,\n            margin_category,\n            liquidation_buffer,\n            include_open_orders,\n            strict,\n            now,\n        )\n        return total_liability_value\n\n    def get_leverage(self, include_open_orders: bool = True) -&gt; int:\n        perp_liability = self.get_perp_market_liability(\n            include_open_orders=include_open_orders\n        )\n        perp_pnl = self.get_unrealized_pnl(True)\n\n        (\n            spot_asset_value,\n            spot_liability_value,\n        ) = self.get_spot_market_asset_and_liability_value(\n            include_open_orders=include_open_orders\n        )\n\n        total_asset_value = spot_asset_value + perp_pnl\n        total_liability_value = spot_liability_value + perp_liability\n\n        net_asset_value = total_asset_value - spot_liability_value\n\n        if net_asset_value == 0:\n            return 0\n\n        return (total_liability_value * 10_000) // net_asset_value\n\n    def get_leverage_components(\n        self,\n        include_open_orders: bool = True,\n        margin_category: Optional[MarginCategory] = None,\n    ):\n        perp_liability = self.get_total_perp_position_value(\n            margin_category, None, include_open_orders\n        )\n\n        perp_pnl = self.get_unrealized_pnl(True, None, margin_category)\n\n        (\n            spot_asset_value,\n            spot_liability_value,\n        ) = self.get_spot_market_asset_and_liability_value(\n            None, margin_category, None, include_open_orders\n        )\n\n        return perp_liability, perp_pnl, spot_asset_value, spot_liability_value\n\n    def get_max_leverage_for_perp(\n        self,\n        perp_market_index: int,\n        margin_category: MarginCategory = MarginCategory.INITIAL,\n        is_lp: bool = False,\n    ):\n        market = self.drift_client.get_perp_market_account(perp_market_index)\n        market_price = self.drift_client.get_oracle_price_data_for_perp_market(\n            perp_market_index\n        ).price\n\n        perp_liab, perp_pnl, spot_asset, spot_liab = self.get_leverage_components()\n\n        total_assets = spot_asset + perp_pnl\n\n        net_assets = total_assets - spot_liab\n\n        if net_assets == 0:\n            return 0\n\n        total_liabs = perp_liab + spot_liab\n\n        lp_buffer = (\n            math.ceil(market_price * market.amm.order_step_size / AMM_RESERVE_PRECISION)\n            if is_lp\n            else 0\n        )\n\n        free_collateral = self.get_free_collateral() - lp_buffer\n\n        match margin_category:\n            case MarginCategory.INITIAL:\n                raw_margin_ratio = max(\n                    market.margin_ratio_initial,\n                    self.get_user_account().max_margin_ratio,\n                )\n            case MarginCategory.MAINTENANCE:\n                raw_margin_ratio = market.margin_ratio_maintenance\n            case _:\n                raw_margin_ratio = market.margin_ratio_initial\n\n        # upper bound for feasible sizing\n        rhs = (\n            math.ceil(\n                ((free_collateral * MARGIN_PRECISION) / raw_margin_ratio)\n                * PRICE_PRECISION\n            )\n        ) / market_price\n        max_size = max(0, rhs)\n\n        # accounting for max size\n        margin_ratio = calculate_market_margin_ratio(\n            market, max_size, margin_category, self.get_user_account().max_margin_ratio\n        )\n\n        attempts = 0\n        while margin_ratio &gt; (raw_margin_ratio + 1e-4) and attempts &lt; 10:\n            rhs = math.ceil(\n                (\n                    ((free_collateral * MARGIN_PRECISION) / margin_ratio)\n                    * PRICE_PRECISION\n                )\n                / market_price\n            )\n\n            target_size = max(0, rhs)\n\n            margin_ratio = calculate_market_margin_ratio(\n                market,\n                target_size,\n                margin_category,\n                self.get_user_account().max_margin_ratio,\n            )\n\n            attempts += 1\n\n        additional_liab = math.ceil((free_collateral * MARGIN_PRECISION) / margin_ratio)\n\n        return math.ceil(((total_liabs + additional_liab) * 10_000) / net_assets)\n\n    def calculate_free_collateral_delta_for_perp(\n        self,\n        market: PerpMarketAccount,\n        perp_position: PerpPosition,\n        position_base_size_change: int,\n    ) -&gt; Union[int, None]:\n        current_base_asset_amt = perp_position.base_asset_amount\n\n        worst_case_base_asset_amt = calculate_worst_case_base_asset_amount(\n            perp_position\n        )\n\n        order_base_asset_amt = worst_case_base_asset_amt - current_base_asset_amt\n\n        proposed_base_asset_amt = current_base_asset_amt + position_base_size_change\n\n        proposed_worst_case_base_asset_amt = (\n            worst_case_base_asset_amt + position_base_size_change\n        )\n\n        margin_ratio = calculate_market_margin_ratio(\n            market, abs(proposed_worst_case_base_asset_amt), MarginCategory.MAINTENANCE\n        )\n\n        margin_ratio_quote_precision = (\n            margin_ratio * QUOTE_PRECISION\n        ) // MARGIN_PRECISION\n\n        if proposed_worst_case_base_asset_amt == 0:\n            return None\n\n        free_collateral_delta = 0\n        if proposed_base_asset_amt &gt; 0:\n            free_collateral_delta = (\n                (QUOTE_PRECISION - margin_ratio_quote_precision)\n                * proposed_base_asset_amt\n            ) // BASE_PRECISION\n        else:\n            free_collateral_delta = (\n                (-QUOTE_PRECISION - margin_ratio_quote_precision)\n                * abs(proposed_base_asset_amt)\n            ) // BASE_PRECISION\n\n        if not order_base_asset_amt == 0:\n            free_collateral_delta = free_collateral_delta - (\n                margin_ratio_quote_precision\n                * abs(order_base_asset_amt)\n                // BASE_PRECISION\n            )\n\n        return free_collateral_delta\n\n    def calculate_free_collateral_delta_for_spot(\n        self, market: SpotMarketAccount, signed_token_amount: int\n    ) -&gt; int:\n        token_precision = 10**market.decimals\n\n        if signed_token_amount &gt; 0:\n            asset_weight = calculate_asset_weight(\n                signed_token_amount,\n                self.get_oracle_data_for_spot_market(market.market_index).price,\n                market,\n                MarginCategory.MAINTENANCE,\n            )\n\n            return (\n                ((QUOTE_PRECISION * asset_weight) // SPOT_MARKET_WEIGHT_PRECISION)\n                * signed_token_amount\n            ) // token_precision\n\n        else:\n            liability_weight = calculate_liability_weight(\n                abs(signed_token_amount), market, MarginCategory.MAINTENANCE\n            )\n\n            return (\n                ((-QUOTE_PRECISION * liability_weight) // SPOT_MARKET_WEIGHT_PRECISION)\n                * abs(signed_token_amount)\n            ) // token_precision\n\n    def get_perp_liq_price(\n        self, perp_market_index: int, position_base_size_change: int = 0\n    ) -&gt; Optional[int]:\n        total_collateral = self.get_total_collateral(MarginCategory.MAINTENANCE)\n        maintenance_margin_req = self.get_margin_requirement(MarginCategory.MAINTENANCE)\n        free_collateral = max(0, total_collateral - maintenance_margin_req)\n\n        market = self.drift_client.get_perp_market_account(perp_market_index)\n        current_perp_pos = self.get_perp_position_with_lp_settle(\n            perp_market_index, burn_lp_shares=True\n        )[0] or self.get_empty_position(perp_market_index)\n\n        free_collateral_delta = self.calculate_free_collateral_delta_for_perp(\n            market, current_perp_pos, position_base_size_change\n        )\n\n        if not free_collateral_delta:\n            return -1\n\n        oracle = market.amm.oracle\n\n        sister_market = None\n        for market in self.drift_client.get_spot_market_accounts():\n            if market.oracle == oracle:\n                sister_market = market\n                break\n\n        if sister_market:\n            spot_position = self.get_spot_position(sister_market.market_index)\n            if spot_position:\n                signed_token_amount = get_signed_token_amount(\n                    get_token_amount(\n                        spot_position.scaled_balance,\n                        sister_market,\n                        spot_position.balance_type,\n                    ),\n                    spot_position.balance_type,\n                )\n\n                spot_free_collateral_delta = (\n                    self.calculate_free_collateral_delta_for_spot(\n                        sister_market, signed_token_amount\n                    )\n                )\n\n                free_collateral_delta = (\n                    free_collateral_delta + spot_free_collateral_delta\n                )\n\n        if free_collateral_delta == 0:\n            return -1\n\n        oracle_price = self.drift_client.get_oracle_price_data_for_perp_market(\n            perp_market_index\n        ).price\n\n        liq_price_delta = (free_collateral * QUOTE_PRECISION) // free_collateral_delta\n\n        liq_price = oracle_price - liq_price_delta\n\n        if liq_price &lt; 0:\n            return -1\n\n        return liq_price\n\n    def get_spot_liq_price(\n        self,\n        spot_market_index: int,\n    ) -&gt; Optional[int]:\n        position = self.get_user_spot_position(spot_market_index)\n        if position is None:\n            return None\n\n        total_collateral = self.get_total_collateral(MarginCategory.MAINTENANCE)\n        margin_req = self.get_margin_requirement(MarginCategory.MAINTENANCE, None, True)\n        delta_liq = total_collateral - margin_req\n\n        spot_market = self.drift_client.get_spot_market_account(spot_market_index)\n        token_amount = get_token_amount(\n            position.scaled_balance, spot_market, position.balance_type\n        )\n        token_amount_qp = token_amount * QUOTE_PRECISION / (10**spot_market.decimals)\n        if abs(token_amount_qp) == 0:\n            return None\n\n        match str(position.balance_type):\n            case \"SpotBalanceType.Borrow()\":\n                liq_price_delta = (\n                    delta_liq\n                    * PRICE_PRECISION\n                    * SPOT_WEIGHT_PRECISION\n                    / token_amount_qp\n                    / spot_market.maintenance_liability_weight\n                )\n            case \"SpotBalanceType.Deposit()\":\n                liq_price_delta = (\n                    delta_liq\n                    * PRICE_PRECISION\n                    * SPOT_WEIGHT_PRECISION\n                    / token_amount_qp\n                    / spot_market.maintenance_asset_weight\n                    * -1\n                )\n            case _:\n                raise Exception(f\"Invalid balance type: {position.balance_type}\")\n\n        price = self.get_oracle_data_for_spot_market(spot_market.market_index).price\n        liq_price = price + liq_price_delta\n        liq_price /= PRICE_PRECISION\n\n        if liq_price &lt; 0:\n            return None\n\n        return liq_price\n\n    def get_empty_position(self, market_index: int) -&gt; PerpPosition:\n        return PerpPosition(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, market_index, 0, 0)\n\n    def get_perp_position_with_lp_settle(\n        self,\n        market_index: int,\n        original_position: PerpPosition = None,\n        burn_lp_shares: bool = False,\n        include_remainder_in_base_amount: bool = False,\n    ) -&gt; Tuple[PerpPosition, int, int]:\n        class UpdateType(Enum):\n            OPEN = \"open\"\n            INCREASE = \"increase\"\n            REDUCE = \"reduce\"\n            CLOSE = \"close\"\n            FLIP = \"flip\"\n\n        original_position = (\n            original_position\n            or self.get_perp_position(market_index)\n            or self.get_empty_position(market_index)\n        )\n\n        if original_position.lp_shares == 0:\n            return original_position, 0, 0\n\n        position = copy.deepcopy(original_position)\n        market = self.drift_client.get_perp_market_account(position.market_index)\n\n        if market.amm.per_lp_base != position.per_lp_base:\n            expo_diff = market.amm.per_lp_base - position.per_lp_base\n            market_per_lp_rebase_scalar = 10 ** abs(expo_diff)\n\n            if expo_diff &gt; 0:\n                position.last_base_asset_amount_per_lp *= market_per_lp_rebase_scalar\n                position.last_quote_asset_amount_per_lp *= market_per_lp_rebase_scalar\n            else:\n                position.last_base_asset_amount_per_lp //= market_per_lp_rebase_scalar\n                position.last_quote_asset_amount_per_lp //= market_per_lp_rebase_scalar\n\n            position.per_lp_base += expo_diff\n\n        n_shares = position.lp_shares\n\n        quote_funding_pnl = calculate_position_funding_pnl(market, position)\n\n        base_unit = int(AMM_RESERVE_PRECISION)\n        if market.amm.per_lp_base == position.per_lp_base:\n            if 0 &lt;= position.per_lp_base &lt;= 9:\n                market_per_lp_rebase = 10**market.amm.per_lp_base\n                base_unit *= market_per_lp_rebase\n            elif position.per_lp_base &lt; 0 and position.per_lp_base &gt;= -9:\n                market_per_lp_rebase = 10 ** abs(position.per_lp_base)\n                base_unit //= market_per_lp_rebase\n            else:\n                raise ValueError(\"cannot calc\")\n        else:\n            raise ValueError(\"market.amm.per_lp_base != position.per_lp_base\")\n\n        delta_baa = (\n            (\n                market.amm.base_asset_amount_per_lp\n                - position.last_base_asset_amount_per_lp\n            )\n            * n_shares\n            // base_unit\n        )\n        delta_qaa = (\n            (\n                market.amm.quote_asset_amount_per_lp\n                - position.last_quote_asset_amount_per_lp\n            )\n            * n_shares\n            // base_unit\n        )\n\n        def sign(v: int) -&gt; int:\n            return -1 if v &lt; 0 else 1\n\n        def standardize(amount: int, step_size: int) -&gt; Tuple[int, int]:\n            remainder = abs(amount) % step_size * sign(amount)\n            standardized_amount = amount - remainder\n            return standardized_amount, remainder\n\n        standardized_baa, remainder_baa = standardize(\n            delta_baa, market.amm.order_step_size\n        )\n\n        position.remainder_base_asset_amount += remainder_baa\n\n        if abs(position.remainder_base_asset_amount) &gt; market.amm.order_step_size:\n            new_standardized_baa, new_remainder_baa = standardize(\n                position.remainder_base_asset_amount, market.amm.order_step_size\n            )\n            position.base_asset_amount += new_standardized_baa\n            position.remainder_base_asset_amount = new_remainder_baa\n\n        dust_base_asset_value = 0\n        if burn_lp_shares and position.remainder_base_asset_amount != 0:\n            oracle_price_data = self.drift_client.get_oracle_price_data_for_perp_market(\n                position.market_index\n            )\n            dust_base_asset_value = (\n                abs(position.remainder_base_asset_amount)\n                * oracle_price_data.price\n                // AMM_RESERVE_PRECISION\n                + 1\n            )\n\n        if position.base_asset_amount == 0:\n            update_type = UpdateType.OPEN\n        elif sign(position.base_asset_amount) == sign(delta_baa):\n            update_type = UpdateType.INCREASE\n        elif abs(position.base_asset_amount) &gt; abs(delta_baa):\n            update_type = UpdateType.REDUCE\n        elif abs(position.base_asset_amount) == abs(delta_baa):\n            update_type = UpdateType.CLOSE\n        else:\n            update_type = UpdateType.FLIP\n\n        if update_type in [UpdateType.OPEN, UpdateType.INCREASE]:\n            new_quote_entry = position.quote_entry_amount + delta_qaa\n            pnl = 0\n        elif update_type in [UpdateType.REDUCE, UpdateType.CLOSE]:\n            new_quote_entry = (\n                position.quote_entry_amount\n                - position.quote_entry_amount\n                * abs(delta_baa)\n                // abs(position.base_asset_amount)\n            )\n            pnl = position.quote_entry_amount - new_quote_entry + delta_qaa\n        else:\n            new_quote_entry = delta_qaa - delta_qaa * abs(\n                position.base_asset_amount\n            ) // abs(delta_baa)\n            pnl = position.quote_entry_amount + delta_qaa - new_quote_entry\n\n        position.quote_entry_amount = new_quote_entry\n        position.base_asset_amount += standardized_baa\n        position.quote_asset_amount = (\n            position.quote_asset_amount\n            + delta_qaa\n            + quote_funding_pnl\n            - dust_base_asset_value\n        )\n        position.quote_break_even_amount = (\n            position.quote_break_even_amount\n            + delta_qaa\n            + quote_funding_pnl\n            - dust_base_asset_value\n        )\n\n        market_open_bids, market_open_asks = calculate_market_open_bid_ask(\n            market.amm.base_asset_reserve,\n            market.amm.min_base_asset_reserve,\n            market.amm.max_base_asset_reserve,\n            market.amm.order_step_size,\n        )\n        lp_open_bids = market_open_bids * position.lp_shares // market.amm.sqrt_k\n        lp_open_asks = market_open_asks * position.lp_shares // market.amm.sqrt_k\n        position.open_bids += lp_open_bids\n        position.open_asks += lp_open_asks\n\n        if position.base_asset_amount &gt; 0:\n            position.last_cumulative_funding_rate = (\n                market.amm.cumulative_funding_rate_long\n            )\n        elif position.base_asset_amount &lt; 0:\n            position.last_cumulative_funding_rate = (\n                market.amm.cumulative_funding_rate_short\n            )\n        else:\n            position.last_cumulative_funding_rate = 0\n\n        remainder_before_removal = position.remainder_base_asset_amount\n\n        if include_remainder_in_base_amount:\n            position.base_asset_amount += remainder_before_removal\n            position.remainder_base_asset_amount = 0\n\n        return position, remainder_before_removal, pnl\n\n    def get_net_spot_market_value(\n        self, with_weight_margin_category: Optional[MarginCategory]\n    ) -&gt; int:\n        (\n            total_asset_value,\n            total_liability_value,\n        ) = self.get_spot_market_asset_and_liability_value(\n            None, with_weight_margin_category\n        )\n\n        return total_asset_value - total_liability_value\n</code></pre>"},{"location":"clearing_house_user/#driftpy.drift_user.DriftUser.__init__","title":"<code>__init__(drift_client, user_public_key, account_subscription=AccountSubscriptionConfig.default())</code>","text":"<p>Initialize the user object</p> <p>Parameters:</p> Name Type Description Default <code>drift_client(DriftClient)</code> <p>required for program_id, idl, things (keypair doesnt matter)</p> required <code>user_public_key</code> <code>Pubkey</code> <p>pubkey for user account</p> required <code>account_subscription</code> <code>Optional[AccountSubscriptionConfig]</code> <p>method of receiving account updates</p> <code>default()</code> Source code in <code>driftpy/drift_user.py</code> <pre><code>def __init__(\n    self,\n    drift_client,\n    user_public_key: Pubkey,\n    account_subscription: Optional[\n        AccountSubscriptionConfig\n    ] = AccountSubscriptionConfig.default(),\n):\n    \"\"\"Initialize the user object\n\n    Args:\n        drift_client(DriftClient): required for program_id, idl, things (keypair doesnt matter)\n        user_public_key (Pubkey): pubkey for user account\n        account_subscription (Optional[AccountSubscriptionConfig], optional): method of receiving account updates\n    \"\"\"\n    from driftpy.drift_client import DriftClient\n\n    self.drift_client: DriftClient = drift_client\n    self.program = drift_client.program\n    self.oracle_program = drift_client\n    self.connection = self.program.provider.connection\n\n    self.user_public_key = user_public_key\n\n    self.account_subscriber = account_subscription.get_user_client_subscriber(\n        self.program, self.user_public_key\n    )\n</code></pre>"}]}